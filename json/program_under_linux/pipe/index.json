{"data":{},"__content":"<h1 id=\"linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E2%80%94%E2%80%94pipe%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89\" tabindex=\"-1\">Linux下进程间通信方式——pipe（管道）</h1>\n<p>先看这一篇文章</p>\n<p><a href=\"https://www.cnblogs.com/wuyepeng/p/9747557.html\">Linux下进程间通信方式——pipe（管道） - cs_wu - 博客园</a></p>\n<p>结合<code>&lt;&lt;understanding unix/linux programming&gt;&gt;</code>这本书的<code>第10章:IO重定向与管道</code>,我希望写出如下的代码,</p>\n<ul>\n<li>popen,运行子进程,并与子进行进行通信</li>\n<li>向子进程写入数据,对他进行读取</li>\n<li>得到子进程的输出信息,与error信息</li>\n</ul>\n<h2 id=\"%E5%89%8D%E7%BD%AE%E7%9A%84%E7%9F%A5%E8%AF%86\" tabindex=\"-1\">前置的知识</h2>\n<p>linux api</p>\n<pre><code>pipe\ndup2\nfcntl\neecvp\n</code></pre>\n<p>管道(pipe)读写的4种情况</p>\n<pre><code class=\"language-plaintext\">\n write    +---------+   read\n --------&gt;|  Pipe   |---------&gt;\n          +---------+\n</code></pre>\n<ol>\n<li>read端如果一直在读,write端不写,会阻塞</li>\n<li>write端如果一直在写,read端不读,会阻塞</li>\n<li>read端如果一直在读,write端写了一部分,然后关闭了,read会读取到EOF,相当于文件的末尾</li>\n<li>write端如果一直在写,read端读了一部分,然后关闭了,write端会得到<code>SIGPIPE</code>信号</li>\n</ol>\n<h2 id=\"%E4%BB%A3%E7%A0%81\" tabindex=\"-1\">代码</h2>\n<p>注意看相应的代码</p>\n<ol>\n<li>利用<code>execvp</code>调用另一个程序</li>\n</ol>\n<p>::: details sample.cpp</p>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;wait.h&gt;\n\nusing T = char * const;\nchar * __argv[100] = {\n    &quot;ls&quot;,&quot;-l&quot;,NULL\n};\n\nint wait_child_exit(int pid){\n    int status;\n    int ret = -1;\n    while ( 1 ) {\n        ret = waitpid(pid, &amp;status, WNOHANG);\n        if( ret == -1) break;\n        if( ret == 0) continue;\n        return pid;\n    }\n    return ret;\n}\n\nint main(){\n    int input_pipe_fd[2]; //写管道\n    int output_pipe_fd[2];//读管道\n    int ret = pipe(input_pipe_fd);\n    if( ret == -1){\n        std::cerr &lt;&lt; &quot;input_pipe_fd create failed&quot; &lt;&lt; &quot;\\n&quot;;\n        return -1;\n    }\n\n    ret = pipe(output_pipe_fd);\n    if( ret == -1){\n        std::cerr &lt;&lt; &quot;output_pipe_fd create failed&quot; &lt;&lt; &quot;\\n&quot;;\n        return -1;\n    }\n\n    int pid = fork();\n\n    auto set_fd_no_close_on_exec = [](int fd){\n        int flags =  fcntl(fd,F_GETFD,0);\n        fcntl(fd, F_SETFD,flags &amp; (~FD_CLOEXEC));\n    };\n\n    if(pid == 0){ // child\n        close(output_pipe_fd[0]); //关闭 output的 读端\n        close(input_pipe_fd[1]); //关闭 intput的 写端\n\n        // dup2(input_pipe_fd[0], 0);\n        dup2(output_pipe_fd[1], 1); //重定向写\n        set_fd_no_close_on_exec(input_pipe_fd[0]);\n        set_fd_no_close_on_exec(0);\n        dup2(output_pipe_fd[1], 1);\n        set_fd_no_close_on_exec(output_pipe_fd[1]);\n        set_fd_no_close_on_exec(1);\n\n        //执行\n        execvp(&quot;ls&quot;,__argv);\n\n    }\n    else { // parent\n        close(output_pipe_fd[1]); //关闭 output的 写端\n        close(input_pipe_fd[0]); //关闭 intput的 读端\n        \n        //读取数据\n        char buf[128];\n\n        while ( 1 ) {\n            \n            int readn = read(output_pipe_fd[0], buf, sizeof(buf));\n            if(readn &lt;= 0) break;\n            for(int i=1;i&lt;=readn;++i){\n                std::cout &lt;&lt; buf[i-1];\n            }\n        }\n\n        int ret = wait_child_exit(pid);\n        std::cout &lt;&lt; &quot;wait child exit ret id: &quot;\n            &lt;&lt; ret\n            &lt;&lt; &quot;\\n&quot;;\n        std::cout &lt;&lt; &quot;\\n main process exit &quot; &lt;&lt; &quot;\\n&quot;;\n\n    }\n\n    return 0;\n}\n</code></pre>\n<p>:::</p>\n<ol start=\"2\">\n<li>测试通信之间的时间间隔问题</li>\n</ol>\n<p>::: details sample_1.cpp</p>\n<pre><code class=\"language-cpp\">// delay\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;wait.h&gt;\n\nusing T = char * const;\nchar * __argv[100] = {\n    &quot;ls&quot;,&quot;-l&quot;,NULL\n};\n\nint wait_child_exit(int pid){\n    int status;\n    int ret = -1;\n    while ( 1 ) {\n        ret = waitpid(pid, &amp;status, WNOHANG);\n        if( ret == -1) break;\n        if( ret == 0) continue;\n        return pid;\n    }\n    return ret;\n}\n\nint main(){\n    int input_pipe_fd[2]; //写管道\n    int output_pipe_fd[2];//读管道\n    int ret = pipe(input_pipe_fd);\n    if( ret == -1){\n        std::cerr &lt;&lt; &quot;input_pipe_fd create failed&quot; &lt;&lt; &quot;\\n&quot;;\n        return -1;\n    }\n\n    ret = pipe(output_pipe_fd);\n    if( ret == -1){\n        std::cerr &lt;&lt; &quot;output_pipe_fd create failed&quot; &lt;&lt; &quot;\\n&quot;;\n        return -1;\n    }\n\n    int pid = fork();\n\n    auto set_fd_no_close_on_exec = [](int fd){\n        int flags =  fcntl(fd,F_GETFD,0);\n        fcntl(fd, F_SETFD,flags &amp; (~FD_CLOEXEC));\n    };\n\n    if(pid == 0){ // child\n        close(output_pipe_fd[0]); //关闭 output的 读端\n        close(input_pipe_fd[1]); //关闭 intput的 写端\n\n        // dup2(input_pipe_fd[0], 0);\n        dup2(output_pipe_fd[1], 1); //重定向写\n        set_fd_no_close_on_exec(input_pipe_fd[0]);\n        set_fd_no_close_on_exec(0);\n        dup2(output_pipe_fd[1], 1);\n        set_fd_no_close_on_exec(output_pipe_fd[1]);\n        set_fd_no_close_on_exec(1);\n\n        //执行\n        const char * child_message = &quot;hello world !&quot;;\n        for(int i=1;i&lt;=3;++i){\n\n            // std::cout &lt;&lt; &quot;print &quot; &lt;&lt; i &lt;&lt; &quot; times&quot; &lt;&lt; std::endl;\n            // std::endl 会把c++ 输出缓存的内容fflush\n\n            write(1,child_message , strlen(child_message));\n            sleep(1);\n        }\n        // https://unix.stackexchange.com/a/430371\n        // fd will automatically closed when process terminates\n        return 0;\n\n    }\n    else { // parent\n        close(output_pipe_fd[1]); //关闭 output的 写端\n        close(input_pipe_fd[0]); //关闭 intput的 读端\n        \n        //读取数据\n        char buf[128];\n\n        char message_buf[128];\n        while ( 1 ) {\n            \n            int readn = read(output_pipe_fd[0], buf, sizeof(buf));\n            //std::cout &lt;&lt; &quot;\\n===&gt; readn bytes : &quot; &lt;&lt; readn &lt;&lt; &quot;\\n&quot;;\n            sprintf(message_buf, &quot;\\n===&gt; readn %d bytes.\\n&quot;,readn);\n            write(1, message_buf, strlen(message_buf));\n            if(readn &lt;= 0) break;\n            // for(int i=1;i&lt;=readn;++i){\n            //     std::cout &lt;&lt; buf[i-1];\n            // }\n            write(1, buf, readn);\n        }\n\n        int ret = wait_child_exit(pid);\n        std::cout &lt;&lt; &quot;wait child exit ret id: &quot;\n            &lt;&lt; ret\n            &lt;&lt; &quot;\\n&quot;;\n        std::cout &lt;&lt; &quot;\\n main process exit &quot; &lt;&lt; &quot;\\n&quot;;\n\n    }\n\n    return 0;\n}\n</code></pre>\n<p>:::</p>\n"}