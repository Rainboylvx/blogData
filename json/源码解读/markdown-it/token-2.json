{"data":{},"__content":"<h1 id=\"token\" tabindex=\"-1\">token</h1>\n<h2 id=\"token-%E7%9A%84%E5%AE%9A%E4%B9%89\" tabindex=\"-1\">token 的定义</h2>\n<ul>\n<li>\n<p><strong>type</strong></p>\n<p>token 的类型，比如 <code>paragraph_open</code> 、<code>paragraph_close</code>、<code>hr</code>，分别会渲染成 <code>&lt;p&gt;</code>、<code>&lt;/p&gt;</code>、<code>&lt;hr&gt;</code>。</p>\n</li>\n<li>\n<p><strong>tag</strong></p>\n<p>标签名称，比如 <code>p</code>、<code>strong</code>、<code>''</code>(空字符串。代表是文字)等等。</p>\n</li>\n<li>\n<p><strong>attrs</strong></p>\n<p>HTML 标签元素的特性，如果存在，则是一个二维数组，比如 <code>[[&quot;href&quot;, &quot;http://dev.nodeca.com&quot;]]</code></p>\n</li>\n<li>\n<p><strong>map</strong></p>\n<p>token 的位置信息，数组只有两个元素，前者是起始行、后者是结束行。</p>\n</li>\n<li>\n<p><strong>nesting</strong></p>\n<p>标签的类型，1 是开标签，0 是自闭合标签，-1 是关标签。例如 <code>&lt;p&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;/p&gt;</code>。</p>\n</li>\n<li>\n<p><strong>level</strong></p>\n<p>缩紧的层级。</p>\n</li>\n<li>\n<p><strong>children</strong></p>\n<p>子token。只有 type 为 inline 或者 image 的 token 会有 children。因为 inline 类型的 token 还会经历一次 parser，提取出更详细的 token，比如以下的场景。</p>\n<pre><code class=\"language-js\">const src = '__advertisement__'\nconst result = md.render(src)\n\n// 首先得到如下的一个 token\n{\n  ...,\n  content:&quot;__Advertisement :)__&quot;,\n  children: [Token, ...]\n}\n// 看出 content 是需要解析并提取出 &quot;__&quot;， &quot;__&quot; 需要被渲染成 &lt;strong&gt; 标签。因此 inline 类型的 children 是用来存放子 token的。\n</code></pre>\n</li>\n<li>\n<p><strong>content</strong></p>\n<p>放置标签之间的内容。</p>\n</li>\n<li>\n<p><strong>markup</strong></p>\n<p>一些特定语法的标记。比如 &quot;```&quot; 表明是一个 code block。&quot;**&quot; 是强调的语法。&quot;-&quot; 或者 &quot;+&quot; 是一个列表。</p>\n</li>\n<li>\n<p><strong>info</strong></p>\n<p>type 为 fence 的 token 会有 info 属性。什么是 fence 呢，如下：</p>\n<pre><code class=\"language-js\">/**\n```js\nlet md = new MarkdownIt()\n```\n**/\n</code></pre>\n<p>上述的注释内部就是 fence token。它的 info 就是 <code>js</code>，<code>markup</code> 是 &quot;```&quot;。</p>\n</li>\n<li>\n<p><strong>meta</strong></p>\n<p>一般插件用来放任意数据的。</p>\n</li>\n<li>\n<p><strong>block</strong></p>\n<p>ParserCore 生成的 token 的 block 为 true，ParserInline 生成的 token 的 block 为 true。</p>\n</li>\n<li>\n<p><strong>hidden</strong></p>\n<p>如果为 true，该 token 不会被 render。</p>\n</li>\n</ul>\n<p>接下来看一下原型上的方法。</p>\n<ul>\n<li>\n<p><strong>attrIndex()</strong></p>\n<pre><code class=\"language-js\">Token.prototype.attrIndex = function attrIndex(name) {\n  var attrs, i, len;\n\n  if (!this.attrs) { return -1; }\n\n  attrs = this.attrs;\n\n  for (i = 0, len = attrs.length; i &lt; len; i++) {\n    if (attrs[i][0] === name) { return i; }\n  }\n  return -1;\n};\n</code></pre>\n<p>根据 attribute name 返回索引。</p>\n</li>\n<li>\n<p><strong>attrPush()</strong></p>\n<pre><code class=\"language-js\">Token.prototype.attrPush = function attrPush(attrData) {\n  if (this.attrs) {\n    this.attrs.push(attrData);\n  } else {\n    this.attrs = [ attrData ];\n  }\n};\n</code></pre>\n<p>添加一个 [name, value] 对。</p>\n</li>\n</ul>\n<p>Token 是 MarkdownIt 内部最基础的类，也是最小的分割单元。它是 parse 的产物，也是 output 的依据。</p>\n"}