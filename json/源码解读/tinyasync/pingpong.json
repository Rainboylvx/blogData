{"data":{},"__content":"<p>ä¸€å£æ°”åˆ° <code>e49c42644cd5ce3e2aaaf35b2d67fc2c494237c5</code>ç¬¬26ä¸ªæäº¤,ping pong benchmark</p>\n<p>è®©æˆ‘ä»¬å¼€å§‹è¯»ä»£ç å§</p>\n<pre><code class=\"language-plaintext\">â”œâ”€â”€ chatroom_server\nâ”œâ”€â”€ condition_variable\nâ”œâ”€â”€ coroutine_task\nâ”œâ”€â”€ echo_server\nâ”œâ”€â”€ http_client\nâ”œâ”€â”€ http_helloworld_server\nâ”œâ”€â”€ lockcore\nâ”œâ”€â”€ mutex\nâ”œâ”€â”€ pingpong\nâ”œâ”€â”€ sleepsort\nâ””â”€â”€ wait\n</code></pre>\n<p>å¤šäº†å¾ˆå¤šçš„æµ‹è¯•</p>\n<pre><code class=\"language-plaintext\">#include &quot;basics.h&quot;\n#include &quot;task.h&quot;\n#include &quot;io_context.h&quot;\n#include &quot;buffer.h&quot;\n#include &quot;awaiters.h&quot;\n#include &quot;mutex.h&quot;\n</code></pre>\n<h2 id=\"1-%E6%A0%B9%E6%8D%AE%E9%A1%BA%E5%BA%8F%E5%85%88%E8%AF%BBbasics.h\" tabindex=\"-1\">1 æ ¹æ®é¡ºåºå…ˆè¯»<code>basics.h</code></h2>\n<pre><code class=\"language-plaintext\">ç±»ä¼¼cçš„printfæ ¼å¼åŒ–æˆstring\nstd::string format(char const* fmt, ...)\n\nchronoè½¬timespec\ntimespec to_timespec(std::chrono::nanoseconds nanoseconds)\n\nsleep\nvoid sync_sleep(std::chrono::nanoseconds nanoseconds)\n\ntypeid(int).name() -&gt; &quot;i&quot;--&gt;&quot;int&quot;\nstd::string abi_name_demangle(const char* abi_name)\n\n\n?? åˆå§‹åŒ– atomic\nTINYASYNC_VCINL T initialize_once(std::atomic&lt;T&gt;&amp; atom, T uninitialized_flag, std::mutex&amp; mtx, L func)\n\n\nusing TypeInfoRef = std::reference_wrapper&lt;const std::type_info&gt;;\nstruct TypeInfoRefHahser \nstruct TypeInfoRefEqualer \ninline  const char * c_name() ?\n\n// socket handle -&gt; c_str\ninline char const* handle_c_str(NativeHandle handle)\ninline char const* socket_c_str(NativeSocket handle)\n\nexception ---&gt; str\nvoid to_string_to(std::exception_ptr const&amp; e, std::string&amp; string_builder)\n\n//? åšä»€ä¹ˆç”¨çš„waiter\nstruct ThisCoroutineAwaiter : std::suspend_always {\n\n\n//exception_ptr -&gt; string\nstd::string to_string(std::exception_ptr const&amp; e)\n\n--&gt; logç”¨\n#ifdef TINYASYNC_TRACE\n\n\næ‰¾åˆ°trivialæ•°æ®,é‚£ä¹ˆç›®çš„æ˜¯ä»€ä¹ˆ\nconstexpr bool is_trivial_parameter_in_itanium_abi_v =\n\n// ä¸ºä»€ä¹ˆå‘¢?\n// you can safely use memcpy\n// you can't safely use memset \ntemplate &lt;class T&gt;\nconstexpr bool has_trivial_five_v =\n\nClass Name\nset_name_r\nthrow_error_\n\n\né˜Ÿåˆ—,æ— è™šç±»é˜Ÿåˆ—?\nlistNode\nQueue\n\nclass TicketSpinLock ?\nclass SysSpinLock \n\n</code></pre>\n<h2 id=\"task.h\" tabindex=\"-1\">task.h</h2>\n<pre><code class=\"language-plaintext\">\n    //resumeä¹‹åçš„ç»“æœ\n    // m_return_from\n    struct ResumeResult;\n\n    template&lt;class Result&gt;\n    class Task;\n\n\n    // operator new and delete æ“ä½œ\n    class TaskPromiseBase {\n\n    //å­˜ç»“æœ\n    template&lt;class Result&gt;\n    class PromiseResultMixin  {\n\n\n    template&lt;&gt;\n    class PromiseResultMixin&lt;void&gt;  {\n\n    //promise_object\n    template&lt;class Result&gt;\n    class TaskPromise : public TaskPromiseBase,\n        public PromiseResultMixin&lt;Result&gt;\n\n    //!æ³¨æ„Final_suspend resumeä»€ä¹ˆä¸œè¥¿\n     continuum è¿™ä¸ªä¸œè¥¿\n\n    std::coroutine_handle&lt;ToPromise&gt; change_promsie(std::coroutine_handle&lt;Promise&gt; h) {\n    A-&gt;B\n\n\n    template&lt;class Result = void&gt;\n    class [[nodiscard]] Task\n    !!æ ¸å¿ƒåœ¨äº Awaiter è¦å®Œæˆçš„åŠŸèƒ½\n\n    inline void destroy_and_throw_if_necessary_impl(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func)\n\n\n    inline bool destroy_and_throw_if_necessary(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func)\n\n\n    inline void throw_impl(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func)\n\n    template&lt;class Result&gt;\n    Task&lt;Result&gt; TaskPromise&lt;Result&gt;::get_return_object()\n\n    inline bool resume_coroutine(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func = &quot;&quot;)\n    {\n\n\n    class YieldAwaiter {\n</code></pre>\n<h2 id=\"io_context\" tabindex=\"-1\">io_context</h2>\n<pre><code class=\"language-plaintext\">\n//åŠŸèƒ½å‡½æ•° è¾“å‡ºä¸€ä¸ªevtä»£è¡¨çš„äº‹ä»¶\nstd::string ioe2str(epoll_event&amp; evt)\n\n//ä¸ä½¿ç”¨virtul table \nCallback\nåŸç† å†…éƒ¨å­˜ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ`m_callback`\n\nstruct CallbackImplBase : Callback\nåŸç†,åˆ©ç”¨templateå‡½æ•°æ¥å­˜å­ç±»çš„ä¿¡æ¯\n\nstruct PostTask\n--&gt; from_node -&gt; ä»å†…éƒ¨çš„æˆå‘˜å˜é‡m_nodeè½¬æˆPostTask*\n--&gt; m_callback\n\nclass IoCtxBase\ninterfaceç±»\n--&gt; run,post_task,request_abort\n\n\nclass IoContext\ntemplate &lt;bool multiple_thread = false&gt;\nIoContext(std::integral_constant&lt;bool, multiple_thread&gt; = std::false_type());\nå®ƒçš„æ„é€ å‡½æ•°å¾ˆç¥å¥‡,--&gt; è§£å†³äº† template constructor æ— æ³•æŒ‡å®š(special)å€¼çš„é—®é¢˜\nhttps://stackoverflow.com/a/3960925/5757674\nä»£ç è§ ./code_continue/1.cpp\n\nåªæ˜¯å¯¹ctxBaseçš„æˆ‘åŒ…è£…\n\n\nstruct SingleThreadTrait\n\nstruct MultiThreadTrait\n\n\n//çœŸæ­£å®ç°\nclass IoCtx : public IoCtxBase\n\næ„é€ å‡½æ•°\n- åˆ›å»ºepoll\n\neventfd ??\nm_wakeup_handle = fd;\n\npost_taskå‡½æ•°\n---- ? thread_waiting æœ‰ä»€ä¹ˆç”¨?\n\nrequire_abort\n\n\næ ¸å¿ƒä¸­çš„æ ¸å¿ƒ--&gt;runå‡½æ•°\n\nå¦‚æœ‰task, å°±åštask\n\nå¤šçº¿ç¨‹ä¸‹çš„ wake_event æœ‰ä»€ä¹ˆç”¨?\n</code></pre>\n<p>Callbackçš„åŸç†è§ <toGitLink file=\"./code_continue/callback.cpp\" /></p>\n<p>æŠ€å·§,</p>\n<h2 id=\"buffer\" tabindex=\"-1\">buffer</h2>\n<pre><code>pool\n\nå®šå¤§å°å†…å­˜æ± ,æ¯ä¸€æ¬¡ç”³è¯·çš„å†…å­˜å¤§å°å›ºå®š,\næ‰€ä»¥freeæ—¶,æŠŠé“¾è¡¨æŠŠä»–ä»¬å›ºå®šåœ¨ä¸€èµ·\n</code></pre>\n<h2 id=\"mutex\" tabindex=\"-1\">mutex</h2>\n<p>ç†è§£<code>mutex.h</code>ä»£ç </p>\n<p>828è¡Œ,å¤ªå¤§äº†ğŸ˜“</p>\n<p>æ ¸å¿ƒç±»</p>\n<pre><code class=\"language-plaintext\">\n- LockCore å¯¹é˜Ÿåˆ—è¿›è¡Œæ“ä½œ?\n  - try_lock\n  - unlock å–é˜Ÿåˆ—çš„å¤´éƒ¨\n- class Mutex;\n  - æˆå‘˜å˜é‡ LockCore,IoContext\n  - MutexLockAwaiter lock() è¿™ä¸ªåº”è¯¥æ˜¯æ ¸å¿ƒåŠŸèƒ½\n- class MutexLockAwaiter; Mutex å¯¹åº”çš„Awaiter\n- class AdoptUniqueLock\n\ntemplate &lt;class Awaiter&gt;\nclass WaitAwaiter;\n\ntemplate &lt;class Awaiter&gt;\nstruct WaitCallback : CallbackImplBase\n\n\nä¸€ä¸ªå‡½æ•°\ntemplate &lt;class Awaiter&gt;\nauto wait(Mutex &amp;mtx, Awaiter &amp;&amp;awaiter) -&gt; WaitAwaiter&lt;std::remove_reference_t&lt;Awaiter&gt; &gt;\n\n\näº‹ä»¶\nclass Event;\nclass EventAwaiter;\n\ntemplate&lt;class Trait&gt;\nclass Condv;\n\ntemplate&lt;class Condv&gt;\nclass CondvAwaiter;\n\nstruct PostTaskEvent : PostTask\n{\n    ListNode *m_awaiters;\n};\n\nclass Event\n</code></pre>\n"}