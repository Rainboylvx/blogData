{"data":{},"__content":"<p>一口气到 <code>e49c42644cd5ce3e2aaaf35b2d67fc2c494237c5</code>第26个提交,ping pong benchmark</p>\n<p>让我们开始读代码吧</p>\n<pre><code class=\"language-plaintext\">├── chatroom_server\n├── condition_variable\n├── coroutine_task\n├── echo_server\n├── http_client\n├── http_helloworld_server\n├── lockcore\n├── mutex\n├── pingpong\n├── sleepsort\n└── wait\n</code></pre>\n<p>多了很多的测试</p>\n<pre><code class=\"language-plaintext\">#include &quot;basics.h&quot;\n#include &quot;task.h&quot;\n#include &quot;io_context.h&quot;\n#include &quot;buffer.h&quot;\n#include &quot;awaiters.h&quot;\n#include &quot;mutex.h&quot;\n</code></pre>\n<h2 id=\"1-%E6%A0%B9%E6%8D%AE%E9%A1%BA%E5%BA%8F%E5%85%88%E8%AF%BBbasics.h\" tabindex=\"-1\">1 根据顺序先读<code>basics.h</code></h2>\n<pre><code class=\"language-plaintext\">类似c的printf格式化成string\nstd::string format(char const* fmt, ...)\n\nchrono转timespec\ntimespec to_timespec(std::chrono::nanoseconds nanoseconds)\n\nsleep\nvoid sync_sleep(std::chrono::nanoseconds nanoseconds)\n\ntypeid(int).name() -&gt; &quot;i&quot;--&gt;&quot;int&quot;\nstd::string abi_name_demangle(const char* abi_name)\n\n\n?? 初始化 atomic\nTINYASYNC_VCINL T initialize_once(std::atomic&lt;T&gt;&amp; atom, T uninitialized_flag, std::mutex&amp; mtx, L func)\n\n\nusing TypeInfoRef = std::reference_wrapper&lt;const std::type_info&gt;;\nstruct TypeInfoRefHahser \nstruct TypeInfoRefEqualer \ninline  const char * c_name() ?\n\n// socket handle -&gt; c_str\ninline char const* handle_c_str(NativeHandle handle)\ninline char const* socket_c_str(NativeSocket handle)\n\nexception ---&gt; str\nvoid to_string_to(std::exception_ptr const&amp; e, std::string&amp; string_builder)\n\n//? 做什么用的waiter\nstruct ThisCoroutineAwaiter : std::suspend_always {\n\n\n//exception_ptr -&gt; string\nstd::string to_string(std::exception_ptr const&amp; e)\n\n--&gt; log用\n#ifdef TINYASYNC_TRACE\n\n\n找到trivial数据,那么目的是什么\nconstexpr bool is_trivial_parameter_in_itanium_abi_v =\n\n// 为什么呢?\n// you can safely use memcpy\n// you can't safely use memset \ntemplate &lt;class T&gt;\nconstexpr bool has_trivial_five_v =\n\nClass Name\nset_name_r\nthrow_error_\n\n\n队列,无虚类队列?\nlistNode\nQueue\n\nclass TicketSpinLock ?\nclass SysSpinLock \n\n</code></pre>\n<h2 id=\"task.h\" tabindex=\"-1\">task.h</h2>\n<pre><code class=\"language-plaintext\">\n    //resume之后的结果\n    // m_return_from\n    struct ResumeResult;\n\n    template&lt;class Result&gt;\n    class Task;\n\n\n    // operator new and delete 操作\n    class TaskPromiseBase {\n\n    //存结果\n    template&lt;class Result&gt;\n    class PromiseResultMixin  {\n\n\n    template&lt;&gt;\n    class PromiseResultMixin&lt;void&gt;  {\n\n    //promise_object\n    template&lt;class Result&gt;\n    class TaskPromise : public TaskPromiseBase,\n        public PromiseResultMixin&lt;Result&gt;\n\n    //!注意Final_suspend resume什么东西\n     continuum 这个东西\n\n    std::coroutine_handle&lt;ToPromise&gt; change_promsie(std::coroutine_handle&lt;Promise&gt; h) {\n    A-&gt;B\n\n\n    template&lt;class Result = void&gt;\n    class [[nodiscard]] Task\n    !!核心在于 Awaiter 要完成的功能\n\n    inline void destroy_and_throw_if_necessary_impl(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func)\n\n\n    inline bool destroy_and_throw_if_necessary(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func)\n\n\n    inline void throw_impl(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func)\n\n    template&lt;class Result&gt;\n    Task&lt;Result&gt; TaskPromise&lt;Result&gt;::get_return_object()\n\n    inline bool resume_coroutine(std::coroutine_handle&lt;TaskPromiseBase&gt; coroutine, char const* func = &quot;&quot;)\n    {\n\n\n    class YieldAwaiter {\n</code></pre>\n<h2 id=\"io_context\" tabindex=\"-1\">io_context</h2>\n<pre><code class=\"language-plaintext\">\n//功能函数 输出一个evt代表的事件\nstd::string ioe2str(epoll_event&amp; evt)\n\n//不使用virtul table \nCallback\n原理 内部存一个函数指针`m_callback`\n\nstruct CallbackImplBase : Callback\n原理,利用template函数来存子类的信息\n\nstruct PostTask\n--&gt; from_node -&gt; 从内部的成员变量m_node转成PostTask*\n--&gt; m_callback\n\nclass IoCtxBase\ninterface类\n--&gt; run,post_task,request_abort\n\n\nclass IoContext\ntemplate &lt;bool multiple_thread = false&gt;\nIoContext(std::integral_constant&lt;bool, multiple_thread&gt; = std::false_type());\n它的构造函数很神奇,--&gt; 解决了 template constructor 无法指定(special)值的问题\nhttps://stackoverflow.com/a/3960925/5757674\n代码见 ./code_continue/1.cpp\n\n只是对ctxBase的我包装\n\n\nstruct SingleThreadTrait\n\nstruct MultiThreadTrait\n\n\n//真正实现\nclass IoCtx : public IoCtxBase\n\n构造函数\n- 创建epoll\n\neventfd ??\nm_wakeup_handle = fd;\n\npost_task函数\n---- ? thread_waiting 有什么用?\n\nrequire_abort\n\n\n核心中的核心--&gt;run函数\n\n如有task, 就做task\n\n多线程下的 wake_event 有什么用?\n</code></pre>\n<p>Callback的原理见 <toGitLink file=\"./code_continue/callback.cpp\" /></p>\n<p>技巧,</p>\n<h2 id=\"buffer\" tabindex=\"-1\">buffer</h2>\n<pre><code>pool\n\n定大小内存池,每一次申请的内存大小固定,\n所以free时,把链表把他们固定在一起\n</code></pre>\n<h2 id=\"mutex\" tabindex=\"-1\">mutex</h2>\n<p>理解<code>mutex.h</code>代码</p>\n<p>828行,太大了😓</p>\n<p>核心类</p>\n<pre><code class=\"language-plaintext\">\n- LockCore 对队列进行操作?\n  - try_lock\n  - unlock 取队列的头部\n- class Mutex;\n  - 成员变量 LockCore,IoContext\n  - MutexLockAwaiter lock() 这个应该是核心功能\n- class MutexLockAwaiter; Mutex 对应的Awaiter\n- class AdoptUniqueLock\n\ntemplate &lt;class Awaiter&gt;\nclass WaitAwaiter;\n\ntemplate &lt;class Awaiter&gt;\nstruct WaitCallback : CallbackImplBase\n\n\n一个函数\ntemplate &lt;class Awaiter&gt;\nauto wait(Mutex &amp;mtx, Awaiter &amp;&amp;awaiter) -&gt; WaitAwaiter&lt;std::remove_reference_t&lt;Awaiter&gt; &gt;\n\n\n事件\nclass Event;\nclass EventAwaiter;\n\ntemplate&lt;class Trait&gt;\nclass Condv;\n\ntemplate&lt;class Condv&gt;\nclass CondvAwaiter;\n\nstruct PostTaskEvent : PostTask\n{\n    ListNode *m_awaiters;\n};\n\nclass Event\n</code></pre>\n"}