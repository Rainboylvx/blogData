{"data":{},"__content":"<p>先看一下<code>epoll_event</code>的定义</p>\n<pre><code class=\"language-plaintext\">epoll_event\n\nstruct ioEvent : public epoll_event ; \nioEvent 就是 epoll_event\n</code></pre>\n<p>定义了一个<code>struct Callback</code>,它的作用很简单,内部定义一个<code>CallBackPtr</code>函数指针变量,\n通过函数<code>callback</code>调用这个指针对就的函数</p>\n<pre><code class=\"language-plaintext\">struct CallbackImplBase : Callback\n</code></pre>\n<p>它的做用是利用内部的模板成员函数使自己成为一个<strong>中转</strong>,调用了类的<code>on_callback</code>方法\n那<strong>中转</strong>实现的原理是什么呢?</p>\n<p>原理是<strong>模板构造函数与成员函数针对不同的子类类型实现不同的重载</strong>,再加上<code>CRTP</code>这个功能</p>\n<pre><code class=\"language-plaintext\">\n  Callback\n    |\n    v\n+---------------------+\n|  CallbackImplBase   |\n+--------+------------+\n         |\n         v\nClass a,b,c,d,....\n\n</code></pre>\n<p>类<code>a,b,c,d</code>最后都转化成<code>Callback</code>的指针,实现了一类似的<code>virtual table</code></p>\n<p>类<code>class PostTask</code>,一个存储类,存<code>m_callback,ListNode m_node</code>\n回调函数,链表节点</p>\n<pre><code class=\"language-plaintext\">class IoCtxBase\n+- from_node_to_post_task 从listnode转成postTask类对象指针\n+- m_epoll_handle\n+- 一些virtual api ,run,post_task,request_abort\n+- 内存管理std::pmr::memory_resource *m_memory_resource;\n</code></pre>\n<pre><code class=\"language-plaintext\">class IoContext\n+- m_ctx\n+- get_io_ctx_base 得到ioCtxBase基类的指针\n+- post_task(PostTask task) 调用task\n+- request_abort 调用m_ctx的\n+- get_memory_resource_for_task 得到 memory_resource 指针\n</code></pre>\n<p>它的构造函数,使用一个技巧,<strong>如何使用编译期间true,false--&gt;intergral_constant</strong></p>\n<p><code>IoContext</code>只是一个包装类,它的功能都是通过<code>m_ctx</code>实现的</p>\n<pre><code class=\"language-plaintext\">\ntemplate &lt;class CtxTrait&gt;\nclass IoCtx : public IoCtxBase\n</code></pre>\n<p>这个类作为<code>IoContext</code>的一个成员函数<code>m_ctx</code></p>\n<p>两个工具类,</p>\n<pre><code class=\"language-plaintext\">struct SingleThreadTrait\nstruct MultiThreadTrait\n</code></pre>\n<pre><code class=\"language-plaintext\">class IoCtx : public IoCtxBase\n</code></pre>\n<p><code>IoCtx</code>是虚基类的实现</p>\n<pre><code class=\"language-plaintext\">+- m_wakeup_handle\n+- m_que_lock  队列锁\n+- m_thread_waiting 线程等待数\n+- m_task_queue_size 任务数量\n+- m_task_queue 任务队列\n+- m_abort_requested 是否abort 请求\n+- k_multiple_thread 是否是多线程\n\n成员函数\n\n+- IoCtx();\n  - 创建epoll\n  - 创建了一个fd作为: m_wakeup_handle,加入epoll事件监控中\n+- void wakeup_a_thread(); 唤醒一个线程\n  - 把m_wakeup_handle加入epoll中\n+- void post_task(PostTask *callback) override;\n  - 单线程:把PostTask加入Queue队列中\n  - 如果是多线程,如何wakeup_a_thread()起作用?\n+- void request_abort() override;\n  - 把m_abort_requested 设为true\n+- void run() override;  执行任务循环\n  - 取出m_task_queue 头部node\n  - 调用task\n  - 无task\n  - 得到effective_event, wakeup_event\n+- ~IoCtx() override;\n</code></pre>\n"}