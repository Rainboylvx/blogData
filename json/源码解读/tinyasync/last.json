{"data":{},"__content":"<p>多了一个memory_pool</p>\n<pre><code class=\"language-plaintext\">PoolNode\nPool\n  m_block_size\n  m_block_per_chunk 一个chunk内的block的数量\n  PoolNode m_heade 头的地址 PoolNode\n  m_chunks 存每一个chunk的指针\n  alloc() 申请内存 ,head 非空就从head里取\n  free() 释放内存,不是真的释放,还是存成一个链表\nFreeNode\nPoolBlock ?\n\nPoolImpl\n\n包含关系 \n---&gt; PoolImpl( PoolBlock(FreeNode))\nPoolResource(PoolImpl)\nFixPoolResource(Pool) Fix是固定的意思吗?\n\nStackfulPoolArg \nstruct StackfulPool 这个是做什么的????\n\nclass FixPoolResource : public std::pmr::memory_resource\n\nclass PoolResource : public std::pmr::memory_resource\n</code></pre>\n<p>example 下面有一个<code>memory_pool</code>的测试,可以帮助理解代码</p>\n<h2 id=\"lockcore.cpp-%E8%A7%A3%E6%9E%90\" tabindex=\"-1\">lockcore.cpp 解析</h2>\n<p>lockcore的定义,应该是锁的抽象,主要的作用应该是给队列加上锁🔒</p>\n<p>实现一个无锁(lockfree)队列</p>\n<pre><code class=\"language-plaintext\">成员变量 Queue-&gt; 一个内部存储 ListNode的队列\n\n常量标记\nstatic constexpr int k_mtx_locked = 1; 已锁\nstatic constexpr int k_que_locked = 2; 队列已锁\nstatic constexpr int k_que_notempty = 4; 队列不空\n\nstd::atomic&lt;int&gt; m_flags = 0; 原子标记flag\n\nis_locked 提示当前是否获得锁\n</code></pre>\n<p>分析<code>try_lock</code>函数,注释说它完的的功能如下:</p>\n<ul>\n<li>如果<code>mutex</code>已锁,返回true</li>\n<li>否则,加入<code>listNode *p</code>,返回false</li>\n</ul>\n<p><code>compare_exchange_strong</code></p>\n<h3 id=\"%E9%87%8D%E7%82%B9%3Atry_lock%E7%9A%84%E8%BF%87%E7%A8%8B\" tabindex=\"-1\">重点:<code>try_lock</code>的过程</h3>\n<pre><code class=\"language-plaintext\">\nlockcore的成员变量设定了一个状态:m_flags,它是一个三元状态,[4,2,1],分别表示\nque_notempty,que_locked,mtx_locked\n\n1.得到 old_flag,也就是此时,m_flags的状态\n\n进行第一轮的锁\n\n- 是否已经 锁 mtx_locked -- NO --&gt; CAS(old_flag,mtx_locked)\n  -- yes--&gt; old_flag.clear(que_locked)  保证que_locked 无锁\n      ---&gt; CAS(old_flags,flag)\n\n第二阶段,\n\nenque true -&gt; 此时锁了 que_locked ,否则 锁了 mtx_locked\n\n要么锁了 mtx_locked\n要么锁了 que_locked\n\n如果 mtx_locked,在debug的状态下\n    -&gt; mtx_thd_cnt+=1 记录有几个线程 通过 mtx_locked 锁住,占用的线程\n    -&gt; return true ,表示锁住了?\n\n如果 que_locked,在debug的状态下\n\n  m_que.push(p)\n    get_old_flag\n    flag.clear(que_locked)\n    flag.set(que_notempty)\n    CAS(old_flags,flag)\n    确实清除了 que_locked 标记\n\n\n</code></pre>\n<h3 id=\"%E9%87%8D%E7%82%B9%3Aunlock%E7%9A%84%E8%BF%87%E7%A8%8B\" tabindex=\"-1\">重点:<code>unlock</code>的过程</h3>\n<pre><code>unlock 发生的事情\n\n得到 old_flags\n\n第一阶段\n  que_empty -&gt; yes -- &gt; flag = clear mtx_mtx_locked -&gt;[ 0|0|0]\n  |\n  |\n  No\n    flag = old_flags | que_locked\n    old_flags -&gt; clear que_locked\nCAS(old_flags ,flag) -&gt; 改成新的状态\n总结:unlock 下\n  如果 队列空 -&gt; m_flag 变成 000\n  不空 flag为old_flag加上que_locked,同时保证CAS时old_flag无que_locked\n\n如果que_empty \n  return nullptr\nelse head = que.pop()\n\n第二阶段\n\n\nflag que_notempty or que_locked\n\nCAS(old_flags,flag), 清空 que_locked 锁\n\n</code></pre>\n<p>可以把整个lockcore认为是一个可以使用的无锁的队列</p>\n<h2 id=\"mutex.cpp-%E8%A7%A3%E6%9E%90\" tabindex=\"-1\">mutex.cpp 解析</h2>\n<p>example 目录下的<code>mutex.cpp</code>写的是<code>mutex.h</code>的测试,理解这个代码可以理解<code>mutex.h</code>代码的目的.</p>\n<h3 id=\"1.-mutex.lock()%E7%9A%84%E4%BD%9C%E7%94%A8\" tabindex=\"-1\">1. <code>mutex.lock()</code>的作用</h3>\n<p>!!! 它加上的锁的作用是什么?或者说明加锁的目的是什么?</p>\n<p>函数定义,返回一个<code>MutexLockAwaiter</code>对象</p>\n<pre><code class=\"language-plaintext\">MutexLockAwaiter lock(IoContext &amp;ctx)\n{\n    return {*this, *ctx.get_io_ctx_base()};\n}\n</code></pre>\n<p>一个<code>awaiter</code>对象运行的过程是</p>\n<p><code>MutexLockAwaiter</code>对象的主要</p>\n<pre><code class=\"language-plaintext\">await_ready -&gt; false 所以直接挂起了\n|\nV\n得到 suspended_coroutine_base\n\n-&gt; 核心是调用了m_mutex的m_lockcore-&gt;try_lock(m_node)\n\n如何 \n\n当第一次执行mtx.lock时,m_lockcore里的元素m_flag为000,也就是flag_mtx_locked = 0\n所以m_lockcore.try_lock() 返回true\nm_lockcore-&gt; try_lock 设置了 mtx_locked -&gt; own_mtx = true -&gt; !own_mtx = false\n      当前的协程没有挂起\n\n如何 m_lockcore-&gt; try_lock 设置了 mtx_que_locked -&gt; own_mtx = false -&gt; !own_mtx = true\n      q 入队了\n      当前的协程没有挂起,\n</code></pre>\n<pre><code class=\"language-plaintext\">mtx.unlock\n\n从lockcore里取出 awaiter\n\n加入到ctx的task list\n</code></pre>\n"}