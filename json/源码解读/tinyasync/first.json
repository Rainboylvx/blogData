{"data":{},"__content":"<p>整个代码1300多行</p>\n<p>分成以几个部分</p>\n<ul>\n<li>log,日志部分,用来表明整个代码运行的过程,具体看,这个提取出来的代码: <toGitLink file=\"./code_first/log.cpp\" /></li>\n<li>io_context io事件的分发中心</li>\n<li>connect 抽象出来一次连接,异步的接收与发送</li>\n<li>AsyncSendAwaiter 异步的等待发送,直接io_context通知可以发送</li>\n<li>AsyncReceiveAwaiter 异步的等待接收,直接io_context通知可以接收</li>\n<li>Acceptor 一系列用于处理新连接的</li>\n<li>spawn 一个协程,目的是把一个task 变成不用再关心的协程,\n这个task是会无限的循环,处理指定的任务</li>\n</ul>\n<p>1 第一部分\nlog</p>\n<p>2 第二部分\nname相关</p>\n<ul>\n<li><code>set_name</code></li>\n<li><code>set_name_r</code></li>\n<li><code>NamedMixin</code>,继承自这个类,那么具体可以自身<code>m_h</code>取名字的能力</li>\n</ul>\n<p>给每一个<code>std::coroutine_handle</code>取个名字</p>\n<p>3 第三部分</p>\n<p>task类的定义</p>\n<p>神奇在是<code>promise_type</code>里有一个<code>std::coroutine_handle&lt;&gt; m_continue = nullptr</code>\n的东西.当前的task执行完后,执行下一个?</p>\n<p>这个<code>m_continue</code>是下面的代码里的<code>Awaiter</code>给它的</p>\n<p>同时task本身是可以<code>co_await</code>的\n先把自己挂起来</p>\n<pre><code class=\"language-cpp\">task func1() {\n\n}\n\ntask func2(){\n  auto task1 = func1();\n  co_await task1;\n}\n</code></pre>\n<p>当另一个协程b内<code>co_await a</code>时,b会挂起,a的内部记录<code>m_continue = b 的corotine hanele</code>\n<code>resume a</code></p>\n<p>让b挂起,a执行,返回执行b的caler\n如果a执行结果到达了,<code>a.promise().final_suspend</code>\n返回一个FinalAwaiter</p>\n<p>测试代码见:</p>\n<toGitLink file=\"./code_first/task.cpp\" />\n<h2 id=\"3-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-spawn\" tabindex=\"-1\">3 第三部分 spawn</h2>\n<p>spawn从字面意思是创建一个不用再关心的协程</p>\n<p>使用代码如下</p>\n<pre><code class=\"language-cpp\">Spawn co_spawn (awaitable awaiter){\n  co_await awaiter; //B\n}\n\nTask myfunc(){\n  await do something;// A\n}\n\nTask func2(){\n  co_spawn(myfunc()); //x\n}\n</code></pre>\n<ol>\n<li>x处调用co_spawn</li>\n<li>myfunc() 会挂起在<code>initial_suspend</code></li>\n<li>B处调用<code>myfunc().Awater::resume</code></li>\n<li>执行到A处,myfunc,挂起,</li>\n<li>myfunc 可能会被其它函数resume,</li>\n<li>可知,当<code>myfunc()</code>结束(<code>final_suspend</code>),<code>co_spawn</code>会被\n<code>m_continue</code>被resume,进而B处结束</li>\n</ol>\n<p><code>spawn</code></p>\n<pre><code class=\"language-plaintext\">initial_suspend  nerver\nfinal_suspend  nerver\n</code></pre>\n<p>过了一段时间后,还是不懂<code>co_spawn</code>运行的原理,下面写一个完整的代码,对应<code>https://cpphub.roj.ac.cn/cpp20/corountines/</code>\n来理解</p>\n<ul>\n<li><strong>为什么co_spawn可以</strong>不在管函数的运行了</li>\n<li><code>co_spawn</code>内的协程挂起来会返回哪里?\n普通函数F调用协程A,\n协程A调用协程B,那么B挂起后,返回到caller,\n那么这个caller是B,还F</li>\n</ul>\n<p>在一个协程内调用另一个协程,</p>\n<pre><code class=\"language-plaintext\">       co_spawn    coroutineA\n      +------+    +------+\nf --&gt; |      |--&gt; |      |\n      |      |    |      |\n      +------+    +------+\n</code></pre>\n<h2 id=\"4-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-iocontext-and-connection\" tabindex=\"-1\">4 第四部分 IoContext and connection</h2>\n<ul>\n<li>Callback的虚函数</li>\n</ul>\n<p>核心在<code>run</code>,从epoll中取出事件,调用<code>evt.data.prt</code>对应的callback</p>\n<ul>\n<li>protocal</li>\n<li>Address::any()</li>\n<li><code>endpoint-&gt;{adress,point}</code></li>\n<li>setnonblocking</li>\n</ul>\n<p>AsyncReceiveAwaiter: 核心,挂起来这后在<code>await_suspend</code>里做的事</p>\n<p>AsyncSendAwaiter,核心同上</p>\n<p>ConnImpl,连接的抽象</p>\n<ul>\n<li>把socket加入到epoll中</li>\n<li>方法<code>async_receive</code> 生成<code>AsyncReceiveAwaiter</code></li>\n<li>定义了一个callback,处理事件</li>\n</ul>\n<h2 id=\"5-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-acceptor\" tabindex=\"-1\">5 第五部分 Acceptor</h2>\n<p>产生一个connection</p>\n<p>使用</p>\n<pre><code>Task listen(IoContext &amp;ctx, Name=&quot;listen&quot;) {\n\n\tAcceptor acceptor(ctx, Protocol::ip_v4(), Endpoint(Address::Any(), 8899));\n\n\tfor (;;) {\n\t\tConnection conn = co_await acceptor.async_accept();\n\t\tco_spawn(echo(ctx, std::move(conn)), &quot;spawn echo&quot;);\n\t}\n}\n</code></pre>\n<ul>\n<li>AcceptAwaiter</li>\n<li>AcceptorImpl</li>\n<li>Acceptor 对上面的简单包装</li>\n</ul>\n<p>AcceptorImpl 构造的过程</p>\n<ol>\n<li>open</li>\n</ol>\n<ul>\n<li><code>auto listenfd = ::socket(PF_INET, SOCK_STREAM, 0);</code>创建fd</li>\n<li><code>setnonblocking</code></li>\n</ul>\n<ol start=\"2\">\n<li>bind</li>\n</ol>\n<ul>\n<li><code>sockaddr_in serveraddr;</code>创建并填充数据</li>\n<li><code>auto binderr = ::bind(listenfd, (sockaddr *)&amp;serveraddr, sizeof(serveraddr));</code></li>\n</ul>\n<ol start=\"3\">\n<li>listen</li>\n</ol>\n<ul>\n<li><code>int err = ::listen(listenfd, max_pendding_connection);</code></li>\n<li>`auto fd3 = epoll_ctl(m_ctx-&gt;handle(), EPOLL_CTL_ADD, listenfd, &amp;evt);</li>\n</ul>\n<h2 id=\"6-timerawaiter-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3\" tabindex=\"-1\">6 TimerAwaiter 定时器相关</h2>\n<p>我没有看</p>\n<h2 id=\"1-q-asyncreceiveawaiter%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8%E6%9C%89%E4%BC%9A%E7%94%A8%3F%E4%B8%BA%E4%BB%80%E4%B9%88\" tabindex=\"-1\">1 Q AsyncReceiveAwaiter中的链表有会用?为什么</h2>\n<p>多次发送?</p>\n<h2 id=\"2-q-%E6%80%8E%E4%B9%88%E7%94%A8%E5%9B%BE%E6%9D%A5%E6%8F%8F%E8%BF%B0%E8%BF%99%E4%B8%AA%E6%A8%A1%E5%9E%8B%3F\" tabindex=\"-1\">2 Q 怎么用图来描述这个模型?</h2>\n<p><img src=\"./img/tinyasync.jpg\" alt=\"\"></p>\n<p>每个<code>awaiter</code>的callback在哪里?</p>\n"}