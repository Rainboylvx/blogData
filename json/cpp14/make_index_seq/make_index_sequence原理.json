{"data":{},"__content":"<blockquote>\n<p>本文由 <a href=\"http://ksria.com/simpread/\">简悦 SimpRead</a> 转码， 原文地址 <a href=\"https://blog.csdn.net/dboyguan/article/details/51706357\">blog.csdn.net</a></p>\n</blockquote>\n<h1 id=\"%E5%8A%9F%E8%83%BD\" tabindex=\"-1\">功能</h1>\n<p>实现编译期的整数序列，如下例 make_index_sequence&lt;3&gt;() 会使 fun 函数的模板参数: int... N 推演为：0，1，2 序列 ：</p>\n<pre><code>#include &lt;iostream&gt; \n#include &lt;tuple&gt;\n \nusing namespace std;\n \ntemplate&lt;int... N&gt;\ndecltype(auto) fun(index_sequence&lt;N...&gt; is) {\n    return make_tuple(N...);\n}\n \nint main() {\n \n    auto t = fun(make_index_sequence&lt;3&gt;());\n    cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; endl;\n    cout &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; endl;\n    cout &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<h1 id=\"%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90\" tabindex=\"-1\">实现分析</h1>\n<h2 id=\"%E5%82%BB%E7%93%9C%E5%BC%8F%E5%AE%9E%E7%8E%B0\" tabindex=\"-1\">傻瓜式实现</h2>\n<p>即是生成一个可变的编译期整数序列，实际上目的就是要生成如下类的对象：</p>\n<pre><code>template&lt;int...N&gt;\nstruct index_sequence {};\n</code></pre>\n<p>定义出上面的 index_sequence 后，其实就可以使用了，仍利用 fun 函数，调用方式为：</p>\n<pre><code>template&lt;int... N&gt;\nstruct index_seq{};\n \ntemplate&lt;int N, int ...M&gt;\nstruct make_index_seq: public make_index_seq&lt;N - 1, N -1, M...&gt; {\n \n};\n \ntemplate&lt;int ...M&gt;\nstruct make_index_seq&lt;0, M...&gt; : public index_seq&lt;M...&gt; {\n};\n</code></pre>\n<p>实际上就是一个空类，因为我们的目的只是模板的可变参数（英文直译应叫模板参数包），并生成一个递增的整数序列，这种实现实际什么都不需要做。</p>\n<h2 id=\"%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%AE%9E%E7%8E%B0\" tabindex=\"-1\">更好的实现</h2>\n<p>分析，c++14 的实现的 make_index_sequence 模板只需指定一个模板参数 “N”，就会自动生成整数序列：0 - N-1，从接口来看：        make_index_sequence&lt;4&gt; 可以实现为 index_sequence 的子类或，一个函数，并返回 index_sequence&lt;0,1,2...&gt; 对象。</p>\n<h3 id=\"%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0\" tabindex=\"-1\">继承方式实现</h3>\n<p>因 c++14 已定义 index_sequence，为避免符号冲突，使用 index_seq 代替。</p>\n<pre><code>template&lt;int... M&gt;\nvoid make_index_seq_impl(std::true_type t) {\n \n}\n \ntemplate&lt;int N, int... M&gt;\nvoid make_index_seq_impl(std::false_type t) {\n \n    (N &lt; 1) ? (make_index_seq_impl&lt;M...&gt;(std::true_type())) : (make_index_seq_impl&lt;N-1, N-1, M...&gt;(std::false_type()));\n}\n</code></pre>\n<p>实现的原理是，当给定一个整数 N，如 3，定义 make_index_seq&lt;3&gt;() 对象时，模板可变参数 M，由空逐渐推导为序列 0，1，2。        即 make_index_seq&lt;3&gt; 时，M 为空。            make_index_seq&lt;3-1,3-1, M...&gt; 时，M 为 3-1 = 2            make_index_seq&lt;2-1,2-1,M...&gt; 时，M 为 2-1=1，2 即序列（1，2）            make_index_seq&lt;1-1,1-1,M...&gt; 时，M 为 1-1 = 0， 1，2 即序列（0，1，2）            make_index_seq&lt;0,M...&gt; 时，           M 为（0，1，2）此时，make_index_seq&lt;3 &gt; 实际继承自 index_seq&lt;0,1,2&gt;       这样就生成了编译期的整数序列。</p>\n<p>对于使用函数方式还不知道是否可行，整体思路的代码如下：</p>\n<pre><code>template&lt;int... M&gt;\nvoid make_index_seq_impl(std::true_type t) {\n \n}\n \ntemplate&lt;int N, int... M&gt;\nvoid make_index_seq_impl(std::false_type t) {\n \n    (N &lt; 1) ? (make_index_seq_impl&lt;M...&gt;(std::true_type())) : (make_index_seq_impl&lt;N-1, N-1, M...&gt;(std::false_type()));\n}\n</code></pre>\n<p>此种写法是不可以的，会导编译器编译时，模板的无穷递归。</p>\n"}