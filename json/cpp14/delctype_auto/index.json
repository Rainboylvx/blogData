{"data":{},"__content":"<p><a href=\"https://en.cppreference.com/w/cpp/language/auto\">Placeholder type specifiers (since C++11) - cppreference.com</a></p>\n<h2 id=\"faq\" tabindex=\"-1\">FAQ</h2>\n<ul>\n<li>如何去理解<code>decltype(auto)</code>?</li>\n<li><code>decltype(auto)</code>与<code>auto</code>有什么不同?</li>\n<li>什么时候使用<code>decltype(auto)</code></li>\n</ul>\n<p>the compilation of <a href=\"https://en.cppreference.com/w/cpp/language/auto\">cppreference</a> is following:</p>\n<p>The placeholder auto may be accompanied by modifiers, such as const or &amp;, which will participate in the type deduction. The placeholder decltype(auto) must be the sole constituent of the declared type. (since C++14)</p>\n<p><strong>Notice:</strong></p>\n<ul>\n<li><code>auto</code> : type is deduced using the rules for <a href=\"https://en.cppreference.com//w/cpp/language/template_argument_deduction#Other_contexts\" title=\"cpp/language/template argument deduction\">template argument deduction</a>.</li>\n<li><code>decltype(type is [</code>decltype(expr)<code>](https://en.cppreference.com/w/cpp/language/decltype &quot;cpp/language/decltype&quot;), where </code>expr<code> is the initializer.)</code></li>\n</ul>\n<pre><code class=\"language-plaintext\">int a;\n(a); // expression type is int &amp;\nauto b = (a); // b type is int\ndecltype(auto) c = (a); // c type is int&amp;\n</code></pre>\n<p><code>auto</code>基本就是原始类型,除非这样<code>auto &amp;</code></p>\n<h2 id=\"%E5%B0%9D%E8%AF%95\" tabindex=\"-1\">尝试</h2>\n<pre><code class=\"language-cpp\">#include &quot;utils.hpp&quot;\n\nint a;\n\nauto func1(){\n    return static_cast&lt;int&amp;&gt;(a);\n}\n\ndecltype(auto) func2(){\n    return static_cast&lt;int&amp;&gt;(a);\n}\n\ndecltype(auto) func3(){\n    return static_cast&lt;int&amp;&amp;&gt;(a);\n}\n\nint main(){\n    log(&quot;auto func1 return type : &quot;,type_name&lt;decltype(func1())&gt;());\n    log(type_name&lt;decltype(func1)&gt;());\n\n    log(&quot;auto func1 return type : &quot;,\n            type_name&lt;std::invoke_result_t&lt;decltype(func1)&gt;&gt;());\n\n    log(&quot;auto func2 return type : &quot;,\n            type_name&lt;std::invoke_result_t&lt;decltype(func2)&gt;&gt;());\n\n    log(&quot;auto func3 return type : &quot;,\n            type_name&lt;std::invoke_result_t&lt;decltype(func3)&gt;&gt;());\n    return 0;\n}\n</code></pre>\n<p>discover: if function return type is <code>decltype(auto)</code> ,then the real of\nreturn type is equal with <strong>the return expression type</strong>.</p>\n<p>According to this <a href=\"https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto\">c++ - What are some uses of decltype(auto)? - Stack Overflow</a></p>\n<h2 id=\"1-use-decltype(auto)-for-perfect-forwarding\" tabindex=\"-1\">1 use <code>decltype(auto)</code> for perfect forwarding</h2>\n<pre><code class=\"language-cpp\">// perfect forwarding of a function call must use decltype(auto)\n// in case the function it calls returns by reference\ntemplate&lt;class F, class... Args&gt;\ndecltype(auto) PerfectForward(F fun, Args&amp;&amp;... args) \n{ \n    return fun(std::forward&lt;Args&gt;(args)...); \n}\n</code></pre>\n<h2 id=\"2-delaying-return-type-deduction-in-recursive-templates\" tabindex=\"-1\">2 Delaying return type deduction in recursive templates</h2>\n<h2 id=\"3-other-uses\" tabindex=\"-1\">3 Other uses</h2>\n<pre><code>int i;\nint&amp;&amp; f();\nauto x3a = i;                  // decltype(x3a) is int\ndecltype(auto) x3d = i;        // decltype(x3d) is int\nauto x4a = (i);                // decltype(x4a) is int\ndecltype(auto) x4d = (i);      // decltype(x4d) is int&amp;\nauto x5a = f();                // decltype(x5a) is int\ndecltype(auto) x5d = f();      // decltype(x5d) is int&amp;&amp;\nauto x6a = { 1, 2 };           // decltype(x6a) is std::initializer_list&lt;int&gt;\ndecltype(auto) x6d = { 1, 2 }; // error, { 1, 2 } is not an expression\nauto *x7a = &amp;i;                // decltype(x7a) is int*\ndecltype(auto)*x7d = &amp;i;       // error, declared type is not plain decltype(auto)\n</code></pre>\n"}