{"data":{},"__content":"<p>#inline namespace</p>\n<pre><code class=\"language-cpp\">#include &lt;stdio.h&gt;\n\nnamespace Outer{\n\n    inline\n    namespace V2{\n        void foo(){\n            printf(&quot;V2::foo()\\n&quot;);\n        }\n    }\n\n    namespace V1{\n        void foo(){\n            printf(&quot;V1::foo()\\n&quot;);\n        }\n    }\n}\n\nint main(){\n\n    Outer::V1::foo();\n    Outer::V2::foo();\n    Outer::foo();\n}\n</code></pre>\n<p>第23行，调用Outer中的默认名字空间V2的foo().</p>\n<p>用途：新版本的升级测试。foo升级到V2版本。如果升级不理想，可以把V1改成inline，V2改成非inline。这将就降级回旧版的foo函数。</p>\n<p>从前是用宏#ifdef V2  ...#endif之类的技术。使用inline namespace带来一个明显的好处是：可以同时使用新版本的foo和旧版本的foo（正如第21行所示）。</p>\n<p><a href=\"https://www.cnblogs.com/thomas76/p/8707609.html\">C++ inline namespace - thomas76 - 博客园</a></p>\n"}