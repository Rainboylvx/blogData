{"data":{},"__content":"<h2 id=\"%E5%89%8D%E6%8F%90\" tabindex=\"-1\">前提</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nusing namespace std;\n\nstruct node { };\n\ntemplate&lt;typename T&gt;\nvoid wrapper(T&amp;&amp; t){ // 万能引用\n    cout &lt;&lt; &quot;T is lvalue reference: &quot;;\n    cout &lt;&lt; is_lvalue_reference&lt;T&gt;::value &lt;&lt; endl;\n    cout &lt;&lt; &quot;T is rvalue reference: &quot;;\n    cout &lt;&lt; is_rvalue_reference&lt;T&gt;::value &lt;&lt; endl;\n    cout &lt;&lt; typeid(T).name() &lt;&lt; endl;\n\n    cout &lt;&lt; &quot;t is lvalue reference: &quot;;\n    cout &lt;&lt; is_lvalue_reference&lt;decltype(t)&gt;::value &lt;&lt; endl;\n    cout &lt;&lt; &quot;t is rvalue reference: &quot;;\n    cout &lt;&lt; is_rvalue_reference&lt;decltype(t)&gt;::value &lt;&lt; endl;\n    cout &lt;&lt; typeid(t).name() &lt;&lt; endl;\n}\n\nint main(){\n    wrapper(node()); // 传递一个右值 T 是node 类型\n    cout &lt;&lt; &quot;=====================&quot; &lt;&lt; endl;\n    node a;\n    wrapper(a); // T 是 node &amp; 类型\n    return 0;\n}\n\n</code></pre>\n<p>原理</p>\n<pre><code class=\"language-cpp\">template&lt;typename T&gt;\nT&amp;&amp; forward( std::remove_reference_t&lt;T&gt;&amp;&amp; t ){\n    return static_cast&lt;T&amp;&amp;&gt;(t);\n}\n</code></pre>\n<p>原理：</p>\n<ul>\n<li>使用万能引用的时候，T的类型可能是<code>node</code>,也可能是<code>node &amp;</code></li>\n<li>引用折叠，如果T是<code>node</code>，那返回的值就是<code>node &amp;&amp;</code></li>\n<li>引用折叠，如果T是<code>node&amp;</code>，那返回的值就是<code>node&amp;&amp;&amp; -&gt; node&amp;</code></li>\n</ul>\n<h2 id=\"%E8%A7%A3%E6%9E%90%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B\" tabindex=\"-1\">解析使用过程</h2>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &quot;utils.hpp&quot;\n\n\ntemplate&lt;typename T&gt;\nT&amp;&amp; my_forward(std::remove_reference_t&lt;T&gt;&amp;&amp; t) {\n    log(&quot;in my_forward 1, type of t is &quot;,type_name&lt;decltype(t)&gt;());\n    return static_cast&lt;T&amp;&amp;&gt;(t);\n}\n\ntemplate&lt;typename T&gt;\nT&amp;&amp; my_forward(std::remove_reference_t&lt;T&gt;&amp; t) {\n    log(&quot;in my_forward 2, type of t is &quot;,type_name&lt;decltype(t)&gt;());\n    return static_cast&lt;T&amp;&amp;&gt;(t);\n}\n\ntemplate&lt;typename T&gt;\nvoid func2(T&amp;&amp; b){\n    log(&quot;func2 argument type&quot;, type_name&lt;decltype(b)&gt;());\n}\n\ntemplate&lt;typename T&gt;\nvoid func1(T&amp;&amp; a){\n    log(&quot;func1 argument type&quot;, type_name&lt;decltype(a)&gt;());\n    //func2(std::forward&lt;T&gt;(a));\n    func2(my_forward&lt;T&gt;(a));\n}\n\n\nint main(){\n    int a = 1;\n    func1(1); // argument type is int&amp;&amp;, T is int\n    cout &lt;&lt; &quot;------------\\n&quot;;\n    func1(a); // argument type is int&amp;, T is int&amp;\n              //\n    cout &lt;&lt; &quot;------------\\n&quot;;\n    int&amp;&amp; b = my_forward&lt;int&amp;&amp;&gt;(1);\n\n    log(&quot;b type : &quot;,type_name&lt;decltype(b)&gt;());\n    return 0;\n}\n\n</code></pre>\n<h3 id=\"func1(1)\" tabindex=\"-1\"><code>func1(1)</code></h3>\n<p><code>func(1)</code>,Obviously the type of argument <code>a</code> is <code>int &amp;&amp; </code>,\nT is <code>int</code>. because of <code>1</code> is rvalue.</p>\n<p>then call <code>std::forward</code> return type <code>int &amp;&amp;</code></p>\n<h3 id=\"func1(a)\" tabindex=\"-1\"><code>func1(a)</code></h3>\n<p><code>func1(a)</code>,Obviously the type of argument <code>a</code> is <code>int &amp; </code>,\nT is <code>int&amp;</code>. because of <code>a</code> is lvalue.</p>\n<pre><code class=\"language-plaintext\">func(int&amp; &amp;&amp; a)-&gt; func(int &amp; a)\n</code></pre>\n<p>then call <code>std::forward</code> return type <code>int &amp;&amp;</code></p>\n"}