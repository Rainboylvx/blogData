{"data":{},"__content":"<h2 id=\"%E8%AF%B4%E6%98%8E\" tabindex=\"-1\">说明</h2>\n<p><code>condition_variable</code>,直译过来就是条件变量</p>\n<p><code>condition_variable</code>是一个同步原语(synchronization primitive),它可以在同一时间阻塞一个或多个线程,直到另一个线程修改了一个共享的变量(条件),并且唤醒<code>condition_variable</code></p>\n<pre><code class=\"language-cpp\">std::condition_variable cv;\n</code></pre>\n<p>当<code>cv.wait</code>被调用的时候，它使用<code>std::unique_lock</code>来锁住当前线程，当前线程会一直被阻塞，直到别一个线程使用<code>cv</code>调用<code>notification</code>函数来唤醒当前线程。</p>\n<ul>\n<li>wait 等待，直到另一个线程调用noitify_one 或 notify_all</li>\n</ul>\n<pre><code class=\"language-cpp\">while( 不能执行的条件 )\n    cv.wait()\n\n=&gt; while( )\n    cv.wait()\n</code></pre>\n<p>当<code>bool(stop_waiting()) == true</code> 时 停止执行</p>\n<ul>\n<li>wait_for</li>\n</ul>\n<p>C++11中lock_guard和unique_lock的特点和区别,condition_variable为何搭配unique_lock使用\n<a href=\"https://blog.csdn.net/KingOfMyHeart/article/details/118076229\">C++11中lock_guard和unique_lock的特点和区别,condition_variable为何搭配unique_lock使用_KingOfMyHeart的博客-CSDN博客</a></p>\n<p>?? 如果一个线程工作的时间比较长，notifi两次会怎么样？会执行两次吗？</p>\n<h2 id=\"%E5%8F%82%E8%80%83%2F%E5%BC%95%E7%94%A8\" tabindex=\"-1\">参考/引用</h2>\n<ul>\n<li><a href=\"https://blog.csdn.net/lv0918_qian/article/details/81745723\">C++11并发编程-条件变量(condition_variable)详解_lv0918_qian的博客-CSDN博客_condition_variable</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/thread/condition_variable\">std::condition_variable - cppreference.com</a></li>\n</ul>\n"}