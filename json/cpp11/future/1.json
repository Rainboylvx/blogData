{"data":{},"__content":"<p><a href=\"https://blog.csdn.net/c_base_jin/article/details/89761718\">C++11之std::future对象使用说明_Keep Moving~-CSDN博客</a>\n<a href=\"https://blog.csdn.net/fengbingchun/article/details/104115489/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242\">C++11中std::future的使用_网络资源是无限的-CSDN博客_c++ future</a></p>\n<ul>\n<li>唯一期望<code>unique future,std::future&lt;&gt;</code></li>\n<li>共享期望<code>shared future std::shared_future</code></li>\n</ul>\n<p>模板类std::future成员函数包括：</p>\n<ol>\n<li>\n<p>构造函数：(1).不带参数的默认构造函数，此对象没有共享状态，因此它是无效的，但是可以通过移动赋值的方式将一个有效的future值赋值给它；(2).禁用拷贝构造；(3).支持移动构造。</p>\n</li>\n<li>\n<p>析构函数：销毁future对象，它是异常安全的。</p>\n</li>\n<li>\n<p>get函数：(1).当共享状态就绪时，返回存储在共享状态中的值(或抛出异常)。(2).如果共享状态尚未就绪(即提供者尚未设置其值或异常)，则该函数将阻塞调用的线程直到就绪。(3).当共享状态就绪后，则该函数将取消阻塞并返回(或抛出)释放其共享状态，这使得future对象不再有效，因此对于每一个future共享状态，该函数最多应被调用一次。(4).<code>std::future&lt;void&gt;</code>::get()不返回任何值，但仍等待共享状态就绪并释放它。(5).共享状态是作为原子操作(atomic operation)被访问。</p>\n</li>\n<li>\n<p>operator=：(1).禁用拷贝赋值。(2).支持移动赋值：如果在调用之前，此对象是有效的(即它已经访问共享状态)，则将其与先前已关联的共享状态解除关联。如果它是与先前共享状态关联的唯一对象，则先前的共享状态也会被销毁。</p>\n</li>\n<li>\n<p>share函数：获取共享的future，返回一个std::shared_future对象，该对象获取future对象的共享状态。future对象将不再有效。</p>\n</li>\n<li>\n<p>valid函数：检查共享状态的有效性，返回当前的future对象是否与共享状态关联。一旦调用了std::future::get()函数，再调用此函数将返回false。</p>\n</li>\n<li>\n<p>wait函数：(1).等待共享状态就绪。(2).如果共享状态尚未就绪(即提供者尚未设置其值或异常)，则该函数将阻塞调用的线程直到就绪。(3).当共享状态就绪后，则该函数将取消阻塞并void返回。</p>\n</li>\n<li>\n<p>wait_for函数：(1).等待共享状态在指定的时间内(time span)准备就绪。(2). 如果共享状态尚未就绪(即提供者尚未设置其值或异常)，则该函数将阻塞调用的线程直到就绪或已达到设置的时间。(3).此函数的返回值类型为枚举类future_status。此枚举类有三种label：ready：共享状态已就绪；timeout：在指定的时间内未就绪；deferred：共享状态包含了一个延迟函数(deferred function)。</p>\n</li>\n<li>\n<p>wait_until函数：(1). 等待共享状态在指定的时间点(time point)准备就绪。(2). 如果共享状态尚未就绪(即提供者尚未设置其值或异常)，则该函数将阻塞调用的线程直到就绪或已达到指定的时间点。(3).此函数的返回值类型为枚举类future_status。</p>\n</li>\n</ol>\n"}