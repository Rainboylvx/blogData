{"data":{"_id":"1bd66912cd","title":"工具库","date":"2021-01-01 21:48","update":"2021-01-01 21:48","author":"Rainboy"},"__content":"<p>@[toc]</p>\n<h2 id=\"declval\" tabindex=\"-1\">declval</h2>\n<p>通常和<code>decltype</code>运算符一起使用,它会返回一个类型的右值引用,实现如下:</p>\n<p>定义在<code>&lt;type_traits&gt;</code>头文件下，核心是把类型作为返回值，这样可以一定具有实例且不用关心构造的问题</p>\n<pre><code class=\"language-c\">template&lt;typename T&gt;\nT __declval(long); \n\ntemplate&lt;typename _Tp&gt;\nstruct __declval_protector\n{\n    static const bool __stop = false;\n};\n\ntemplate&lt;typename _Tp&gt;\nauto declval() noexcept -&gt; decltype(__declval&lt;_Tp&gt;(0))\n{\n    static_assert(__declval_protector&lt;_Tp&gt;::__stop, //只能在编译的时候用,不能实际的执行\n\t\t    &quot;declval() must not be used!&quot;);\n    return __declval&lt;_Tp&gt;(0);\n}\n\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-c\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n\nstruct Test {\n    Test()=delete;\n    int foo(){\n        return 0;\n    }\n};\n\nint main(){\n    decltype(std::declval&lt;Test&gt;().foo()) a;\n    cout &lt;&lt; std::is_same&lt;decltype(a),int&gt;::value;\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n"}