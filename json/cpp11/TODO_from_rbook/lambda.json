{"data":{},"__content":"<h1 id=\"lambda\" tabindex=\"-1\">lambda</h1>\n<p>lambda表达式在其所在的位置上定义了一个匿名函数对象。构造闭包：能够俘获作用域中的变量的无名函数对象</p>\n<pre><code class=\"language-c\">[ 俘获 ] &lt;模板形参&gt;(可选)(C++20) ( 形参 ) 说明符(可选) 异常说明 attr -&gt; ret requires(可选)(C++20) { 函数体 }\n[ 俘获 ] ( 形参 ) -&gt; ret { 函数体 }\n[ 俘获 ] ( 形参 ) { 函数体 }\n[ 俘获 ] { 函数体 }\n</code></pre>\n<pre><code class=\"language-plaintext\">[函数对象参数] (操作符重载函数参数) mutable或exception声明 -&gt;返回值类型 {函数体}\n\n一、[函数对象参数]，标识一个Lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：\n\n\n1、空。没有使用任何函数对象参数。\n\n2、=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。\n\n           3、&amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。\n\n4、this。函数体内可以使用Lambda所在类中的成员变量。\n           5、a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。\n6、&amp;a。将a按引用进行传递。\n7、a, &amp;b。将a按值进行传递，b按引用进行传递。\n8、=，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。\n9、&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。\n\n1.[var]表示值传递方式捕捉变量var；\n2.[=]表示值传递方式捕捉所有父作用域的变量（包括this）；\n3.[&amp;var]表示引用传递捕捉变量var；\n4.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）；\n5.[this]表示值传递方式捕捉当前的this指针。\n\n上面提到了一个父作用域，也就是包含Lambda函数的语句块，说通俗点就是包含Lambda的“{}”代码块。上面的捕捉列表还可以进行组合，例如：\n\n1.[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量;\n2.[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。\n\n不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。例如：\n\n3.[=,a]这里已经以值传递方式捕捉了所有变量，但是重复捕捉a了，会报错的;\n4.[&amp;,&amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。\n\n二、(操作符重载函数参数)，标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。\n      三、mutable或exception声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)。\n\n四、`-&gt;`返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。\n\n五、{函数体}，标识函数的实现，这部分不能省略，但函数体可以为空。\n</code></pre>\n<h3 id=\"a%2Bb\" tabindex=\"-1\">a+b</h3>\n<pre><code class=\"language-c\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main(){\n    int a,b;\n    cin &gt;&gt; a &gt;&gt; b;\n    auto lambda_func = [=]()-&gt;int{\n        return a+b;\n    };\n    cout &lt;&lt; lambda_func();\n    return 0;\n}\n</code></pre>\n<h2 id=\"2\" tabindex=\"-1\">2</h2>\n<pre><code class=\"language-c\">#include&lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int j = 10;\n    auto by_val_lambda = [=]{ return j + 1; };\n    auto by_ref_lambda = [&amp;]{ return j + 1; };\n    cout&lt;&lt;&quot;by_val_lambda: &quot;&lt;&lt;by_val_lambda()&lt;&lt;endl;\n    cout&lt;&lt;&quot;by_ref_lambda: &quot;&lt;&lt;by_ref_lambda()&lt;&lt;endl;\n\n    ++j;\n    cout&lt;&lt;&quot;by_val_lambda: &quot;&lt;&lt;by_val_lambda()&lt;&lt;endl;\n    cout&lt;&lt;&quot;by_ref_lambda: &quot;&lt;&lt;by_ref_lambda()&lt;&lt;endl;\n\n    return 0;\n}\n</code></pre>\n<p>输出</p>\n<pre><code class=\"language-plaintext\">by_val_lambda: 11\nby_ref_lambda: 11\nby_val_lambda: 11\nby_ref_lambda: 12\n</code></pre>\n<p>你想到了么？？？那这又是为什么呢？为什么第三个输出不是12呢？\n在by_val_lambda中，j被视为一个常量，一旦初始化后不会再改变（可以认为之后只是一个跟父作用域中j同名的常量），而在by_ref_lambda中，j仍然在使用父作用域中的值。所以，在使用Lambda函数的时候，如果需要捕捉的值成为Lambda函数的常量，我们通常会使用按值传递的方式捕捉；相反的，如果需要捕捉的值成成为Lambda函数运行时的变量，则应该采用按引用方式进行捕捉。</p>\n<h2 id=\"%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\" tabindex=\"-1\">参考资料</h2>\n<ul>\n<li><a href=\"https://zh.cppreference.com/w/cpp/language/lambda\">cppreference.com Lambda 表达式</a></li>\n<li><a href=\"https://blog.csdn.net/pleasecallmewhy/article/details/34941721\">C++11 语法记录: Lambda简单入门</a></li>\n<li><a href=\"https://blog.csdn.net/lcalqf/article/details/79401210\">C++ 11 Lambda表达式 通俗易懂</a></li>\n</ul>\n"}