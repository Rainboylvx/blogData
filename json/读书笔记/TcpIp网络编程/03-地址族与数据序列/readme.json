{"data":{},"__content":"<h1 id=\"%E5%88%86%E9%85%8D%E7%BB%99%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84ip%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7\" tabindex=\"-1\">分配给套接字的IP地址与端口号</h1>\n<h2 id=\"%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80\" tabindex=\"-1\">网络地址</h2>\n<ul>\n<li>\n<p>IPv4:4字节地址</p>\n</li>\n<li>\n<p>IPv6:16字节地址</p>\n</li>\n<li>\n<p>A类网络地址首字节范围：0~127</p>\n</li>\n<li>\n<p>B类网络地址首字节范围：128~191</p>\n</li>\n<li>\n<p>C类网络地址首字节范围：192~223</p>\n</li>\n</ul>\n<h1 id=\"%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA\" tabindex=\"-1\">地址信息的表示</h1>\n<h2 id=\"%E8%A1%A8%E7%A4%BAipv4%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93\" tabindex=\"-1\">表示IPv4地址的结构体</h2>\n<pre><code>struct sockaddr_in\n{\n    sa_family_t sin_family; //地址族\n    uint16_t sin_port;      //16位端口号\n    struct in_addr sin_addr;//32位IP地址\n    char zero[8];           //不使用\n}\n\nstruct in_addr\n{\n    in_addr_t s_addr;   //32位IP地址\n}\n\nstruct sockaddr\n{\n    sa_family_t sin_family;\n    char sa_data[14];\n}\n</code></pre>\n<h2 id=\"ipv6%E7%9A%84%E7%9B%B8%E5%85%B3%E7%96%91%E9%97%AE\" tabindex=\"-1\">ipv6的相关疑问</h2>\n<p><code>sockaddr</code>只有14个字节来存端口与ip地址,那如果来存ipv6呢,ipv6的地址就有16个字节</p>\n<p>真正来存ipv6相关信息是<code>sockaddr_in6</code>,就像使用<code>sockaddr_in</code>来存ipv4,</p>\n<p>我猜测,注意,只是我的猜测,\n<code>sockaddr</code>只是作为一个指针来使用,系统使用它的时候,先分析它的<code>sin_family</code>来决定,这个<code>sockaddr</code>指针,指向的是<code>sockaddr_in</code>还是<code>sockaddr_in6</code></p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/24817642/sockaddr-and-ipv6-address\">c - sockaddr and IPv6 address - Stack Overflow</a></li>\n<li><a href=\"https://stackoverflow.com/questions/13504934/binding-sockets-to-ipv6-addresses\">c - Binding Sockets to IPv6 Addresses - Stack Overflow</a></li>\n</ul>\n<h1 id=\"%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\" tabindex=\"-1\">网络字节序列与地址转换</h1>\n<h2 id=\"%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97\" tabindex=\"-1\">字节序与网络字节序列</h2>\n<ul>\n<li>大端序（Big Endian）：小(个位)放<strong>大</strong>(高)地址,0x1234 存的是时候,[0x12,0x34]</li>\n<li>小端序(Little Endian)：小(个位)放<strong>小</strong>(低)地址,0x1234 存的是时候,[0x34,0x12]</li>\n<li>网络字节序列(Network Byte Order)：统一为大端序</li>\n</ul>\n<h2 id=\"%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E8%BD%AC%E6%8D%A2(endian-conversions)\" tabindex=\"-1\">字节序列转换(Endian Conversions)</h2>\n<pre><code>unsigned short htons(unsigned short);    //主机字节序-&gt;网络字节序\nunsigned short ntohs(unsigned short);    //网络字节序列-&gt;主机字节序列\nunsigned long htonl(unsigned long);      \nunsigned long ntohl(unsigned long);\n</code></pre>\n<h1 id=\"%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%88%86%E9%85%8D\" tabindex=\"-1\">网络地址的初始化与分配</h1>\n<h2 id=\"%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%A1%E6%81%AF%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B4%E6%95%B0%E5%9E%8B\" tabindex=\"-1\">将字符串信息转换为网络字节序列的整数型</h2>\n<p>字符串ip,例如,<code>127.0.0.1</code>与 <code>unsigned long,in_addr</code>的相互转换</p>\n<pre><code>#include&lt;arpa/inet.h&gt;\n\n// 字符串 转成 unsigned long ,in_addr_t 就是 unsigned long\nin_addr_t inet_addr(const char* string);\n//成功时返回32位大端序列整型数值，失败时返回INADDR_NONE\n\nint inet_aton(const char* string, struct in_addr* addr);\n//成功时返回true，失败时返回false\n\nchar* inet_ntoa(struct in_addr addr);\n</code></pre>\n"}