{"data":{},"__content":"<h1 id=\"%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\" tabindex=\"-1\">理解线程的概念</h1>\n<h3 id=\"%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BC%BA%E7%82%B9\" tabindex=\"-1\">多进程模型的缺点</h3>\n<ul>\n<li>创建进程的过程会带来一定的开销</li>\n<li>进程间完成数据交换需要用到特殊的IPC技术</li>\n<li>进程的上下文切换带来巨大的开销</li>\n</ul>\n<h3 id=\"%E7%BA%BF%E7%A8%8B%E7%9B%B8%E6%AF%94%E4%BA%8E%E8%BF%9B%E7%A8%8B%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A\" tabindex=\"-1\">线程相比于进程具有如下的优点：</h3>\n<ul>\n<li>线程的创建和上下文的切换比进程的创建和上下文切换速度更快</li>\n<li>线程间的数据交换不需要用到特殊的技术</li>\n</ul>\n<h3 id=\"%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82\" tabindex=\"-1\">进程和线程的差异</h3>\n<p>每个进程间的内存空间都是独立的，内存空间包括三个部分：数据区（保存全局变量）、堆区域（动态分配内存）、栈区域（函数运行时使用、局部变量）。<br>\n多个线程间的静态数据区和堆区域是共享的，只有栈区域时独立的。这种方式可以获得如下优势：</p>\n<ul>\n<li>上下文切换时不需要切换数据区和堆区域</li>\n<li>可以通过数据区和堆交换数据</li>\n</ul>\n<h1 id=\"%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%BF%90%E8%A1%8C\" tabindex=\"-1\">线程创建及运行</h1>\n<pre><code>#include&lt;pthread.h&gt;\nint pthread_create(\n    pthread_t* restrict thread, const pthread_attr_t* restrict attr, \n    void* (*start_routine)(void*), void* restrict arg\n);\n//成功时返回0，失败时返回其他值\n</code></pre>\n<pre><code>#include&lt;pthread.h&gt;\nint pthread_join(pthread_t p_id, void** status);\n//成功时返回0，失败时返回-1\n</code></pre>\n<h1 id=\"%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\" tabindex=\"-1\">线程同步</h1>\n<p>线程同步用于解决线程访问顺序引发的问题，需要同步的情况可以从如下两方面考虑：</p>\n<ul>\n<li>同时访问同一内存空间时发生的情况</li>\n<li>需要指定访问同一内存空间时线程的执行顺序的情况</li>\n</ul>\n<h2 id=\"%E4%BA%92%E6%96%A5%E9%87%8F\" tabindex=\"-1\">互斥量</h2>\n<pre><code>#include&lt;pthread.h&gt;\nint pthread_mutex_init(pthread_mutex_t* mutex, const pthread_mutexattr_t* attr);\nint pthread_mutex_destroy(pthread_mutex_t* mutex);\n//成功时返回0，失败时返回其他值\n</code></pre>\n<ul>\n<li>mutex:保存互斥量的变量地址值</li>\n<li>attr:传递创建互斥量属性，没有特别需要指定的属性指定NULL</li>\n</ul>\n<pre><code>#include&lt;pthread.h&gt;\nint pthread_mutex_lock(pthread_mutex_t* mutex);\nint pthread_mutex_unlock(pthread_mutex_t* mutex);\n</code></pre>\n<h2 id=\"%E4%BF%A1%E5%8F%B7%E9%87%8F\" tabindex=\"-1\">信号量</h2>\n<pre><code>#include&lt;semaphore.h&gt;\nint sem_init(sem_t* sem, int pshared, unsigned int value);\nint sem_destroy(sem_t* sem);\n//成功时返回0，失败时返回其他值\n</code></pre>\n<ul>\n<li>sem:保存信号量的变量地址值</li>\n<li>pshared:传递其他值时，创建多个进程共享的信号量，传递0时，创建只允许一个进程使用的信号量</li>\n<li>value:指定初始值</li>\n</ul>\n<pre><code>#include&lt;semaphore.h&gt;\nint sem_post(sem_t* sem);\nint sem_wait(sem_t* sem);\n//成功时返回0，失败时返回其他值\n</code></pre>\n<ul>\n<li>sem:传递给sem_post时信号量增加1，传递给sem_wait时信号量减少1</li>\n</ul>\n<h2 id=\"pthread_detach\" tabindex=\"-1\">pthread_detach</h2>\n<pre><code>#include&lt;pthread.h&gt;\nint pthread_detach(pthread_t thread);\n//成功时返回0，失败时返回其他值\n</code></pre>\n<p>调用此函数后不能再调用pthread_join,调用该函数的线程不会阻塞，该函数引导线程结束之后销毁线程空间。</p>\n"}