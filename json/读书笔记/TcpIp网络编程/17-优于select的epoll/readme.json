{"data":{},"__content":"<h1 id=\"epoll%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8\" tabindex=\"-1\">epoll理解及应用</h1>\n<h2 id=\"%E5%9F%BA%E4%BA%8Eselect-i%2Fo%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0\" tabindex=\"-1\">基于select I/O复用技术速度慢的原因</h2>\n<ul>\n<li>调用select函数后针对所有监视的文件描述符循环遍历</li>\n<li>每次调用select函数需要向操作系统传递所有的监视对象信息</li>\n</ul>\n<h2 id=\"%E5%AE%9E%E7%8E%B0epoll%E6%97%B6%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93\" tabindex=\"-1\">实现epoll时必要的函数和结构体</h2>\n<h3 id=\"epoll_create\" tabindex=\"-1\">epoll_create</h3>\n<pre><code>#include&lt;sys/epoll.h&gt;\nint epoll_create(int size);\n//成功时返回epoll文件描述符，失败时返回-1\n</code></pre>\n<ul>\n<li>size:epoll实例的大小，在2.6.8版本以上的内核将完全忽略该参数</li>\n</ul>\n<blockquote>\n<p>epoll_create函数创建的资源与套接字相同，由操作系统管理。该函数返回的文件描述符主要用于区分不同的epoll实例。需要终止时，和其他文件描述符一样，需要调用close()函数。</p>\n</blockquote>\n<h3 id=\"epoll_ctl\" tabindex=\"-1\">epoll_ctl</h3>\n<pre><code>#include&lt;sys/epoll.h&gt;\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);\n//成功时返回0，失败时返回-1\n</code></pre>\n<ul>\n<li>epfd: epoll实例的文件描述符</li>\n<li>op：用于指定监视对象的添加，删除，更改等操作。</li>\n<li>fd：需要注册的监视对象文件描述符</li>\n<li>event:监视对象的事件类型</li>\n</ul>\n<hr>\n<p>第二个参数传递的常量及含义如下：</p>\n<ul>\n<li>EPOLL_CTL_ADD:将文件描述符注册到epoll实例中</li>\n<li>EPOLL_CTL_DEL:将文件描述符从epoll中删除</li>\n<li>EPOLL_CTL_MOD:更改注册的文件描述符的关注事件发生情况</li>\n</ul>\n<hr>\n<p>第四个参数的详细定义如下：</p>\n<pre><code>struct epoll_event{\n    __uint32_t events;  //  事件类型\n    epoll_data_t data;\n}\n\ntypedef union epoll_data{\n    void* ptr;\n    int fd;\n    __uint_32_t u32;\n    __uint_64_t u64;\n}epoll_data_t;\n</code></pre>\n<p>events事件类型：</p>\n<ul>\n<li>EPOLLIN:需要读取数据的情况</li>\n<li>EPOLLOUT：输出缓冲为空，可以立即发送数据</li>\n<li>EPOLLPRI:收到OOB（带外数据）的情况</li>\n<li>EPOLLRDHUP:断开连接或半关闭的情况，这在边缘出发方式下非常有用</li>\n<li>EPOLLERR:发生错误的情况</li>\n<li>EPOLLET:以边缘触发的方式得到事件通知</li>\n<li>EPOLLONESHOT:发生一次事件后，相应文件描述符不再收到事件通知。因此需要再次设置事件。</li>\n</ul>\n<pre><code>//epoll_ctl调用示例\nstruct epoll_event event;\nevent.events = EPOLLIN;\nevent.fd = sockfd;\nepoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;event);\n</code></pre>\n<h3 id=\"epoll_wait\" tabindex=\"-1\">epoll_wait</h3>\n<pre><code>#include&lt;sys/epoll.h&gt;\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n//成功时返回发生了事件的文件描述符的数量，失败时返回-1\n</code></pre>\n<ul>\n<li>epfd:epoll实例的文件描述符</li>\n<li>events:表示发生事件的文件描述符集合的结构体地址</li>\n<li>maxevents:第二个参数中可以表示的最大的事件数</li>\n<li>timeout:以1毫秒为单位的等待时间，传递-1时，一直等待到发生事件</li>\n</ul>\n<pre><code>//代码示例\nstruct epoll_event* ep_events;\nep_events = malloc(sizeof(epoll_event)*EPOLL_SIZE);\nint event_cnt = epoll_wait(epfd, ep_events, EPOLL_SIZE, -1);\n</code></pre>\n<h1 id=\"%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91\" tabindex=\"-1\">水平触发和边缘触发</h1>\n<h2 id=\"%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E4%B8%8E%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%E5%8F%91%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9\" tabindex=\"-1\">水平触发与边缘触发的区别在于发生事件的时间点</h2>\n<blockquote>\n<p>水平触发方式中，只要输入缓冲中有数据就会一直通知该事件。<br>\n边缘触发方式中，输入缓冲区收到数据时只会通知一次事件，即使输入缓冲中还有未读取数据也不会再次通知。</p>\n</blockquote>\n<h2 id=\"%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%B8%AD%E5%BF%85%E7%9F%A5%E7%9A%84%E4%B8%A4%E7%82%B9\" tabindex=\"-1\">边缘触发的服务端实现中必知的两点</h2>\n<ul>\n<li>通过errno变量验证错误的原因</li>\n<li>更改套接字为非阻塞的方式</li>\n</ul>\n<blockquote>\n<p>边缘触发方式中，接收数据时只会通知一次该事件，因此需要一次性将所有的数据读完。因此需要验证输入缓冲中是否为空。<br>\n<strong>read函数返回-1，变量<code>errno</code>中的值为<code>EAGAIN</code>时，说明没有数据可读。</strong><br>\n为了访问<code>errno</code>变量需要包含<code>#include&lt;errno.h&gt;</code>。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>在边缘触发方式中，如果套接字时阻塞方式工作，那么read&amp;write函数有可能引起服务器的长时间停顿，因此在边缘触发方式中一定要将套接字更改为非阻塞的方式。</p>\n</blockquote>\n<pre><code>//更改文件属性函数\n#include&lt;fcntl.h&gt;\nint fcntl(int filedes, int cmd, ...);\n</code></pre>\n<pre><code>//更改套接字为非阻塞方式\nint flag = fcntl(fd, F_GETFL,0);\nfcntl(fd, FSETFL, flag|O_NONBLOCK);\n</code></pre>\n<h2 id=\"%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%A3\" tabindex=\"-1\">水平触发和边缘触发的优劣</h2>\n<p>边缘触发可以分离接收数据和处理数据的时间点，从实现模型的角度看边缘触发有可能带来高性能。</p>\n"}