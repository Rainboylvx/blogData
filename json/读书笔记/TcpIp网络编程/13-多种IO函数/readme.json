{"data":{},"__content":"<h1 id=\"send-%26-recv%E5%87%BD%E6%95%B0\" tabindex=\"-1\">send &amp; recv函数</h1>\n<pre><code>#include&lt;sys/socket.h&gt;\n\nssize_t send(int sockfd, const void* buf, size_t nbytes, int flags);\n//成功时返回发送的字节数，失败时返回-1\n\nssize_t recv(int sockfd, const void* buf, size_t nbytes, int flags);\n//成功时返回接收到的字节数（收到EOF时返回0），失败时返回-1\n</code></pre>\n<blockquote>\n<p>这两个函数的最后一个参数是收发数据时的可选项，可以进行按位于'|'运算符进行指定多个选项，可选项及其含义如下：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">可选项(Option)</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">send</th>\n<th style=\"text-align:center\">recv</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">MSG_OOB</td>\n<td style=\"text-align:center\">用于传输带外的数据（out-of-band data)</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MSG_PEEK</td>\n<td style=\"text-align:center\">验证输入缓冲中是否存在接收的数据</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">Y</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MSG_DONTROUTE</td>\n<td style=\"text-align:center\">数据传输过程中不参照路由表，在本地网络中寻找目的地</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">N</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MSG_DONTWAIT</td>\n<td style=\"text-align:center\">调用IO函数时不阻塞</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">Y</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MSG_WAITALL</td>\n<td style=\"text-align:center\">防止函数返回，直到接收请求的全部的字节数</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">Y</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"fcntl%E5%87%BD%E6%95%B0\" tabindex=\"-1\">fcntl函数</h1>\n<pre><code>#include&lt;fcntl.h&gt;\n\nfcntl(sockRecv, F_SETOWN, getpid());\n</code></pre>\n<blockquote>\n<p>上述函数调用的作用是：将文件描述符<code>sockRecv</code>指向的拥有者改为<code>getpid()</code>函数返回的ID的进程；处理SIGURG信号时必须指定处理信号的进程.</p>\n</blockquote>\n<h1 id=\"%E6%A3%80%E6%9F%A5%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2\" tabindex=\"-1\">检查输入缓冲</h1>\n<blockquote>\n<p><code>MSG_PEEK</code>和<code>MSG_DONTWAIT</code>同时使用时可以用来检查输入缓冲区是否有待接收的数据，并且不会删除这些数据.</p>\n</blockquote>\n<h1 id=\"readv-%26-writev%E5%87%BD%E6%95%B0\" tabindex=\"-1\">readv &amp; writev函数</h1>\n<pre><code>#include&lt;sys/uio.h&gt;\n\nssize_t writev(int filedes, const struct iovec* iov, int iovcnt);\n//成功时返回发送的字节数，失败时返回-1\n\nssizea_t readv(int filedes, const struct iovec* iov, int iovcnt);\n</code></pre>\n<ul>\n<li>filedes:文件描述符</li>\n<li>iov:iovec结构体数组的首地址</li>\n<li>iovcnt:第二个参数数组的长度</li>\n</ul>\n<pre><code>struct iovec\n{\n    void* iov_base; //缓冲地址\n    size_t iov_len; //缓冲大小\n}\n</code></pre>\n<h2 id=\"%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95\" tabindex=\"-1\">我的测试</h2>\n<p>如果server在<code>write</code>数据的时候,client端突然断开(电脑停电,程序崩溃等),<code>write</code>可以把数据写到缓冲区,接着会<code>read</code>到\nclient的断开(也就是read返回值为0)</p>\n"}