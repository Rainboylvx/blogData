{"data":{},"__content":"<h1 id=\"%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E5%8D%8A%E5%85%B3%E9%97%AD\" tabindex=\"-1\">基于TCP的半关闭</h1>\n<h2 id=\"%E5%8D%95%E6%96%B9%E9%9D%A2%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98\" tabindex=\"-1\">单方面断开连接带来的问题</h2>\n<p>在A、B两个主机进行通信的过程中，A在发送了最后一条数据之后，直接调用close(sockFd);将套接字的读和写两个方向的输入流和输出流同时关闭，若在此时B主机正在向A主机发送数据那么这条数据将无法接收到。</p>\n<h2 id=\"%E5%A5%97%E6%8E%A5%E5%AD%97%E5%92%8C%E6%B5%81\" tabindex=\"-1\">套接字和流</h2>\n<p>两台主机一旦建立了连接之后，两台主机上会分别产生输入流和输出流，进行双向通信，一个主机的输入流与另一个主机的输出流相连，优雅的断开套接字即只断开一个方向上的数据流，而非同时断开输入、输出流。</p>\n<h2 id=\"%E9%92%88%E5%AF%B9%E4%BC%98%E9%9B%85%E6%96%AD%E5%BC%80%E7%9A%84shutdown%E5%87%BD%E6%95%B0\" tabindex=\"-1\">针对优雅断开的shutdown函数</h2>\n<pre><code>int shutdown(int sock, int howto);\n//成功时返回0，失败时返回-1\n</code></pre>\n<p>howto:断开连接的方式，可能的取值如下：</p>\n<ul>\n<li>SHUT_RD:断开输入流</li>\n<li>SHUT_WR:断开输出流</li>\n<li>SHUT_RDWR:同时断开输入流和输出流</li>\n</ul>\n<blockquote>\n<p>断开输入流时若输入缓冲中有数据则输入缓冲中的数据将会被清除，断开输出流时若输出缓冲中仍然有未发送的数据，则会将输出缓冲中的数据发送到对方主机中。</p>\n</blockquote>\n<h2 id=\"%E6%B5%8B%E8%AF%95\" tabindex=\"-1\">测试</h2>\n<p>Q:如果 client 关闭 shutdown的时候,server 是如何得知的呢?</p>\n<p>A: 通过read == 0 得知. <code>shutdown(ser_sock,SHUT_WR)</code>会发送一个FIN包,相当于EOF,server端read后返回0</p>\n<blockquote>\n<blockquote>\n<p>My understanding of what it will do is that it will prevent the client application from further sending the data and thus will also prevent the server side from further attempting to read any data.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Your understanding is correct.</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>What I cant understand is that why is it used in this program …</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>As your own statement suggests, without the client's <code>s.shutdown(socket.SHUT_WR)</code> the server would not quit waiting for data, but instead stick in its <code>sc.recv(1024)</code> forever, because there would be no connection termination request sent to the server.<br>\nSince the server then would never get to its <code>sc.close()</code>, the client on his part also would not quit waiting for data, but instead stick in its <code>s.recv(42)</code> forever, because there would be no connection termination request sent from the server.<br>\nReading <a href=\"https://stackoverflow.com/a/23483487/2413201\">this answer to &quot;close vs shutdown socket?&quot;</a> might also be enlightening.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>from <a href=\"https://stackoverflow.com/a/36397712/19867157\">https://stackoverflow.com/a/36397712/19867157</a></p>\n</blockquote>\n<p>Q: 如果 client shutdown(server_fd ,shutdown_RD),那么server还能写入吗,write会有错误吗?</p>\n<p>A: server端能写入,但是client接收不到,或者接收到就在缓冲区丢弃数据.根据这个:<a href=\"https://stackoverflow.com/questions/740817/behavior-of-shutdownsock-shut-rd-with-tcp\">networking - Behavior of shutdown(sock, SHUT_RD) with TCP - Stack Overflow</a></p>\n"}