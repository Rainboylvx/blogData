{"data":{},"__content":"<h2 id=\"starting-out\" tabindex=\"-1\">Starting Out</h2>\n<h2 id=\"ready%2Cset%2Cgo!\" tabindex=\"-1\">Ready,set,go!</h2>\n<p>讲了数值计算,和<code>c++</code>一样,</p>\n<p><code>5/2=2.5</code></p>\n<p>执行<code>5 * -3</code>会使ghci报错,像<code>5*(-3)</code>就不会有问题。</p>\n<p>逻辑运行符号:<code>&amp;&amp;,||,not</code></p>\n<p><code>5 /= 4 -&gt; True</code></p>\n<p>类型自动转换<code>5+4.0</code></p>\n<p><code>*</code>是一个函数</p>\n<p><code>succ</code>是一个函数</p>\n<p><code>succ 9 *10 -&gt; 100</code> 运算符优先级</p>\n<p><code>div 92 10 equ 92 \\</code>div`10 `</p>\n<p><code>div 92 10 -&gt; 92</code> 整除</p>\n<p><code>bar(bar 3) -&gt; bar(bar(3))</code> 相等</p>\n<h2 id=\"2.2-baby's-first-function\" tabindex=\"-1\">2.2 Baby's first function</h2>\n<p>函数的声明与它的调用形式大体相同，都是先函数名，后跟由空格分隔的参数表。但在声明中一定要在 = 后面定义函数的行为。</p>\n<pre><code class=\"language-plaintext\">double x = x+x\n\n两个参数的函数\ndouble x y = x*2 + y*2\n\n调用其它函数\ndoubleUs x y = doubleMe x + doubleMe y\n</code></pre>\n<p>haskell中的函数并没有顺序,先定义哪个都可以</p>\n<p>我们编写一个函数，它将小于100的数都乘以2，因为大于100的数都已经足够大了！</p>\n<pre><code class=\"language-plaintext\">doubleSmallNumber x = if x &gt; 100 then x else x*2\n</code></pre>\n<p>else不能省略</p>\n<ul>\n<li>haskell中每个函数和表表达式,都必须返回一个结果</li>\n<li>if是一个表达式</li>\n</ul>\n<pre><code class=\"language-plaintext\">doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1\n</code></pre>\n<h2 id=\"list\" tabindex=\"-1\">List</h2>\n<p>List是一种单类型的数据结构</p>\n<p>可以用<code>let</code>定义一个名字(变量名),但不用好像也没有什么区别</p>\n<p>合并</p>\n<pre><code class=\"language-plaintext\">[1,2,3] ++ [2,3,4] -&gt; [1,2,3,2,3,4]\n&quot;hello&quot; ++ &quot; &quot; ++ &quot;world&quot;\n  -&gt; hello world\n</code></pre>\n<pre><code class=\"language-plaintext\">ghci&gt; 'A':&quot; SMALL CAT&quot;   \n&quot;A SMALL CAT&quot;   \nghci&gt; 5:[1,2,3,4,5]  \n[5,1,2,3,4,5] \n\n1:2:3[]\n</code></pre>\n<p><code>:</code>运算符可以连接一个元素到一个List或者字符串之中\n<code>[1,2,3]</code>实际上是<code>1:2:3:[]</code>的语法糖</p>\n<p>索引运算 <code>!!</code></p>\n<pre><code class=\"language-plaintext\">(1:2:3:[] )!! 2\n-&gt;3\n</code></pre>\n<p>List中的List可以是不同长度，但必须得是相同的类型</p>\n<p>当List内装有可比较的元素时,List是可比较的</p>\n<pre><code class=\"language-plaintext\">[3,2,1] &gt; [2,1,0]\n</code></pre>\n<p>其它操作</p>\n<pre><code class=\"language-plaintext\">head [5,4,3,2,1]  \ntail [5,4,3,2,1]   \nlast [5,4,3,2,1]   \ninit [5,4,3,2,1]   \nhead []   &gt; error\nlength [5,4,3,2,1]   \nnull [1,2,3]  \nnull [1,2,3]  \nreverse [5,4,3,2,1]   \ntake 3 [5,4,3,2,1]   \ntake 5 [1,2]   \ntake 0 [6,6,6]  \n drop 3 [8,4,2,1,5,6]   \nminimum [8,4,2,1,5,6]   \nmaximum [1,9,2,3,4]   \nsum [5,2,1,6,3,2,5,7]   \nproduct [6,2,1,2]   \n4 `elem` [3,4,5,6]   \n10 `elem` [3,4,5,6]   \n</code></pre>\n<h2 id=\"%E5%BE%B7%E5%B7%9E%E5%8C%BA%E9%97%B4-texas-ranges\" tabindex=\"-1\">德州区间 Texas ranges</h2>\n<p>这个很像python的列表生成</p>\n<pre><code class=\"language-plaintext\">[1..20]\n['a'..'z']\n['A'..'z']\n</code></pre>\n<pre><code class=\"language-plaintext\">[2,4..20]\n[2,4,6,8,10,12,14,16,18,20]\n\n[3,6..20]\n[3,6,9,12,15,18]\n</code></pre>\n<pre><code class=\"language-plaintext\">[20..1] 会得到一个空list []\n\n正确的做法\n[20,19..1]\n</code></pre>\n<p>不指定<code>upper limit</code>来创建一个无限的list</p>\n<pre><code class=\"language-plaintext\">[1..]\n</code></pre>\n<p>由于 Haskell 是惰性的，它不会对无限长度的 List 求值，否则会没完没了的.\n它会等着，看你会从它那儿取多少。</p>\n<p>下面写一个常用的操作</p>\n<pre><code class=\"language-plaintext\">cycle\nrepeat\ntake\n\ntake 10 (cycl)\n\nghci&gt; take 10 [1..]\n[1,2,3,4,5,6,7,8,9,10]\n\nghci&gt; take 10 (repeat 10)\n[10,10,10,10,10,10,10,10,10,10]\n\n\nghci&gt; take 10 (cycle [1,2,3])\n[1,2,3,1,2,3,1,2,3,1]\n\nghci&gt; take 10 (cycle &quot;LOL &quot;)\n&quot;LOL LOL LO&quot;\n\nghci&gt; replicate 3 10\n[10,10,10]\n</code></pre>\n<p>使用<code>replicate</code>来得到一些同样数字的列表</p>\n<h2 id=\"i'm-a-list-comprehension\" tabindex=\"-1\">I'm a list comprehension</h2>\n<p>得到前10个偶数</p>\n<pre><code class=\"language-plaintext\">ghci&gt; take 10 [2,4..]\n[2,4,6,8,10,12,14,16,18,20]\n</code></pre>\n<p>list comprehension,使用更复杂的function</p>\n<pre><code class=\"language-plaintext\">ghci&gt; [ x*2 | x &lt;- [1..10]]\n[2,4,6,8,10,12,14,16,18,20]\n</code></pre>\n<p>more predicates</p>\n<pre><code class=\"language-plaintext\">ghci&gt; [ x*2 | x &lt;- [1..10],x*2&gt;=12]\n[12,14,16,18,20]\n</code></pre>\n<p>取 50 到 100 间所有除 7 的余数为 3 的元素</p>\n<pre><code class=\"language-plaintext\">ghci&gt; [ x | x &lt;- [50..100],mod x 7 == 3]\n[52,59,66,73,80,87,94]\n</code></pre>\n<p>odd函数</p>\n<pre><code class=\"language-plaintext\">ghci&gt; odd 3\nTrue\nghci&gt; odd 4\nFalse\n</code></pre>\n<p>也可以加多个限制条件。若要达到 10 到 20 间所有不等于 13，15 或 19 的数，可以这样：</p>\n<pre><code class=\"language-plaintext\">ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]   \n[10,11,12,14,16,17,18,20]\n</code></pre>\n<p>从多个 List 中取元素</p>\n<p>假设有两个 List，[ 2 , 5 , 10 ] 和 [ 8 , 10 , 11 ] ， 要取它们所有组合的积，可以这样：</p>\n<pre><code>ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]   \n[16,20,22,40,50,55,80,100,110]  \n</code></pre>\n<p>若只取乘积大于 50 的结果该如何？</p>\n<pre><code class=\"language-plaintext\">ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]   \n[55,80,100,110]  \n</code></pre>\n<p>取个包含一组名词和形容词的 List comprehension 吧，写诗的话也许用得着。</p>\n<pre><code>ghci&gt; let nouns = [&quot;hobo&quot;,&quot;frog&quot;,&quot;pope&quot;]   \nghci&gt; let adjectives = [&quot;lazy&quot;,&quot;grouchy&quot;,&quot;scheming&quot;]   \nghci&gt; [adjective ++ &quot; &quot; ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]   \n[&quot;lazy hobo&quot;,&quot;lazy frog&quot;,&quot;lazy pope&quot;,&quot;grouchy hobo&quot;,&quot;grouchy frog&quot;, &quot;grouchy pope&quot;,&quot;scheming hobo&quot;, \n&quot;scheming frog&quot;,&quot;scheming pope&quot;] \n</code></pre>\n<p>sum函数,<code>_</code>表示我们不关心得到的数据</p>\n<pre><code class=\"language-plaintext\">ghci&gt; length1 xs = sum [1 | x &lt;- xs]\nghci&gt; length1 [1,2,3]\n3\n</code></pre>\n<pre><code class=\"language-plaintext\">removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']]  \n</code></pre>\n<p>嵌套的 List comprehension ,对内部的每一个list单独过滤</p>\n<pre><code class=\"language-plaintext\">ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]   \nghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]   \n[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]] \n</code></pre>\n<h2 id=\"tuple\" tabindex=\"-1\">Tuple</h2>\n<p>tuple与list的不同就是,teupl有的类型由内部的类型与本身元素的数量决定</p>\n<p>tuple的内部元素的类型不一定是相同的</p>\n<pre><code class=\"language-plaintext\">[(1,1),(2,2),(3,3)]\n[(1,1),(2,2,2),(3,3)] -&gt; error\n[(1,1),(&quot;one&quot;,2)] -&gt; error\n</code></pre>\n<pre><code class=\"language-plaintext\">ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]   \n[(1,5),(2,5),(3,5),(4,5),(5,5)]\n\n\nghci&gt; zip [1 .. 5] [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]   \n[(1,&quot;one&quot;),(2,&quot;two&quot;),(3,&quot;three&quot;),(4,&quot;four&quot;),(5,&quot;five&quot;)]\n\n\n\nghci&gt; zip [1..] [&quot;apple&quot;, &quot;orange&quot;, &quot;cherry&quot;, &quot;mango&quot;]   \n[(1,&quot;apple&quot;),(2,&quot;orange&quot;),(3,&quot;cherry&quot;),(4,&quot;mango&quot;)]\nghci&gt; \n\n\nghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2]\nghci&gt; rightTriangles \n[(3,4,5),(6,8,10)]\n</code></pre>\n"}