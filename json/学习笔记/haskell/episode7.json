{"data":{},"__content":"<h1 id=\"%E6%A8%A1%E5%9D%97\" tabindex=\"-1\">模块</h1>\n<p>就像python一样,学习一下haskell模块的使用</p>\n<h2 id=\"%E8%A3%85%E8%BD%BD%E6%A8%A1%E5%9D%97\" tabindex=\"-1\">装载模块</h2>\n<pre><code class=\"language-plaintext\">import Data.List\nghci&gt; :m Data.List\nghci&gt; :m Data.List Data.Map Data.Set\nimport Data.List (nub，sort)\nimport Data.List hiding (nub)\nimport qualified Data.Map\nimport qualified Data.Map as M\n</code></pre>\n<h2 id=\"data.list\" tabindex=\"-1\">Data.List</h2>\n<p>显而易见，Data.List是关于List操作的模块，它提供了一组非常有用的List处理函数。</p>\n<p>intersperse取一个元素与List作参数，并将该元素置于List中每对元素的中间。如下是个例子:</p>\n<pre><code>ghci&gt; intersperse '.' &quot;MONKEY&quot;   \n&quot;M.O.N.K.E.Y&quot;   \nghci&gt; intersperse 0 [1,2,3,4,5,6]   \n[1,0,2,0,3,0,4,0,5,0,6]\n</code></pre>\n<p>intercalate取两个List作参数。它会将第一个List交叉插入第二个List中间，并返回一个List.</p>\n<pre><code>ghci&gt; intercalate &quot; &quot; [&quot;hey&quot;,&quot;there&quot;,&quot;guys&quot;]   \n&quot;hey there guys&quot;   \nghci&gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]   \n[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]追光\n</code></pre>\n<p>transpose函数可以反转一组List的List。你若把一组List的List看作是个2D的矩阵，那transpose的操作就是将其列为行。</p>\n<pre><code>ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]   \n[[1,4,7],[2,5,8],[3,6,9]]   \nghci&gt; transpose [&quot;hey&quot;,&quot;there&quot;,&quot;guys&quot;]   \n[&quot;htg&quot;,&quot;ehu&quot;,&quot;yey&quot;,&quot;rs&quot;,&quot;e&quot;]\n</code></pre>\n<ul>\n<li>concat</li>\n<li>concatMap</li>\n<li>and</li>\n<li>or</li>\n<li>any</li>\n<li>splitAt 将该List在特定的位置断开。返回一个包含两个List的二元组</li>\n<li>takeWhile这一函数十分的实用。它从一个List中取元素，一旦遇到不符合条件的某元素就停止.</li>\n<li>dropWhile与此相似，不过它是扔掉符合条件的元素。一旦限制条件返回False，它就返回List的余下部分。方便实用!</li>\n<li>span</li>\n<li>break</li>\n<li>sort</li>\n<li>group 相邻</li>\n<li>inits</li>\n<li>tails</li>\n<li>find ,返回的是<code>Maybe a</code></li>\n<li>findIndex</li>\n<li>findIndices</li>\n<li>elemIndex</li>\n<li>elemIndices</li>\n<li>zip3,zip4...</li>\n<li>zipWith3,zipWith4...</li>\n<li>lines</li>\n<li>unlines</li>\n<li>words</li>\n<li>unwords</li>\n<li>nub</li>\n<li>delete</li>\n<li><code>\\\\</code> 差集操作</li>\n<li>union</li>\n<li>intersection</li>\n<li>insert</li>\n<li>很多的更通用的替代版:generic</li>\n<li>groupby</li>\n</ul>\n<p><code>nub</code>,<code>delete</code>,<code>union</code>,<code>intsect</code>和<code>group</code>函数也有各自的通用替代版<code>nubBy</code>，<code>deleteBy</code>，<code>unionBy</code>，<code>intersectBy</code>和<code>groupBy</code>，它们的区别就是前一组函数使用(==)来测试是否相等，而带By的那组则取一个函数作参数来判定相等性，group就与groupBy (==)等价.</p>\n<p>同样，<code>sort</code>，<code>insert</code>，<code>maximum</code>和<code>min</code>都有各自的通用版本。如<code>groupBy</code>类似，sortBy，insertBy，maximumBy和minimumBy都取一个函数来比较两个元素的大小。像sortBy的类型声明为:<code>sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code>。前面提过，Ordering类型可以有三个值,<code>LT</code>，<code>EQ</code>和<code>GT</code>。<code>compare</code>取两个Ord类型类的元素作参数，所以<code>sort</code>与<code>sortBy compare</code>等价.</p>\n<p>Maybe型的值只能为空或者单一元素</p>\n<h2 id=\"data.char\" tabindex=\"-1\">Data.Char</h2>\n<p>如其名，<code>Data.Char</code>模块包含了一组用于处理字符的函数。由于字符串的本质就是一组字符的List，所以往往会在filter或是map字符串时用到它.</p>\n<p>???</p>\n<pre><code class=\"language-plaintext\">findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; v  \nfindKey key xs = snd . head . filter (\\(k,v) -&gt; key == k) $ xs\n</code></pre>\n<h2 id=\"data.map\" tabindex=\"-1\">Data.Map</h2>\n<h2 id=\"data.set\" tabindex=\"-1\">Data.Set</h2>\n<h2 id=\"%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A8%A1%E5%9D%97\" tabindex=\"-1\">建立自己的模块</h2>\n"}