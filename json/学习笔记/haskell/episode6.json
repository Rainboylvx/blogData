{"data":{},"__content":"<h1 id=\"%E7%AC%AC6%E7%AB%A0-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\" tabindex=\"-1\">第6章 高阶函数</h1>\n<h2 id=\"%E6%9F%AF%E9%87%8C%E5%87%BD%E6%95%B0\" tabindex=\"-1\">柯里函数</h2>\n<p>所有多个参数的函数都是柯里函数。</p>\n<pre><code class=\"language-plaintext\">compareWithHundred :: (Num a，Ord a) =&gt; a -&gt; Ordering \ncompareWithHundred x = compare 100 x\n</code></pre>\n<pre><code>compareWithHundred :: (Num a，Ord a) =&gt; a -&gt; Ordering \ncompareWithHundred = compare 100\n</code></pre>\n<p>为什么类型声明依然相同 ???</p>\n<pre><code class=\"language-plaintext\">divideByTen :: (Floating a) =&gt; a -&gt; a \ndivideByTen = (/10)\n</code></pre>\n<p>调用<code>divideByTen 200</code>就是<code>(/10) 200</code>，和<code>200 / 10</code>等价。</p>\n<p>将参数减4的函数，就用<code>subtract</code>好了，像这样<code>(subtract 4)</code>.</p>\n<h2 id=\"%E6%98%AF%E6%97%B6%E5%80%99%E4%BA%86%EF%BC%8C%E6%9D%A5%E7%82%B9%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%81\" tabindex=\"-1\">是时候了，来点高阶函数！</h2>\n<p>haskell中的函数可以取另一个函数做参数，也可以返回函数。 举个例子，我们弄个取一个函数并调用它两次的函数.</p>\n<p>那这样的话,c++也可以有高阶函数</p>\n<pre><code class=\"language-plaintext\">applyTwice :: (a -&gt; a) -&gt; a -&gt; a   \napplyTwice f x = f (f x)\n</code></pre>\n<p>它标明了首个参数是个参数与返回值类型都是a的函数</p>\n<pre><code class=\"language-plaintext\">zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]   \nzipWith' _ [] _ = []   \nzipWith' _ _ [] = []   \nzipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys\n</code></pre>\n<p>flip简单地取一个函数作参数并返回一个相似的函数，只是它们的两个参数倒了个。</p>\n<pre><code class=\"language-plaintext\">flip' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)   \nflip' f = g   \n    where g x y = f y x #?? 这里能简单的定义函数吗\n</code></pre>\n<p>从这类型声明中可以看出，它取一个函数，其参数类型分别为a和b，而它返回的函数的参数类型为b和a。 由于函数默认都是柯里化的，<code>-&gt;</code>为右结合，这里的第二对括号其实并无必要，<code>(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code>与<code>(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>等价,也与<code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>等价。 前面我们写了<code>g x y = f y x</code>，既然这样可行，那么<code>f y x = g x y</code>不也一样? 这一来我们可以改成更简单的写法:</p>\n<pre><code>flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c   \nflip' f y x = f x y\n</code></pre>\n<h2 id=\"map-%E4%B8%8E-filter\" tabindex=\"-1\">map 与 filter</h2>\n<p>map取一个函数和List做参数，遍历该List的每个元素来调用该函数产生一个新的List。 看下它的类型声明和实现:</p>\n<pre><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]   \nmap _ [] = []   \nmap f (x:xs) = f x : map f xs\n</code></pre>\n<p>filter函数取一个限制条件和一个List，返回该List中所有符合该条件的元素。 它的类型声明及实现大致如下:</p>\n<pre><code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]   \nfilter _ [] = []   \nfilter p (x:xs)    \n    | p x       = x : filter p xs   \n    | otherwise = filter p xs\n</code></pre>\n<pre><code class=\"language-plaintext\">quicksort :: (Ord a) =&gt; [a] -&gt; [a]     \nquicksort [] = []     \nquicksort (x:xs) =      \n    let smallerSorted = quicksort (filter (&lt;x) xs) \n        biggerSorted = quicksort (filter (&gt;x) xs)    \n    in  smallerSorted ++ [x] ++ biggerSorted\n</code></pre>\n<h2 id=\"lambda\" tabindex=\"-1\">lambda</h2>\n<p>lambda 就是匿名函数</p>\n<p>同普通函数一样，你也可以在 lambda 中使用模式匹配，只是你无法为一个参数设置多个模式，如 <code>[]</code> 和 <code>(x:xs)</code>。lambda 的模式匹配若失败，就会引发一个运行时错误，所以慎用！</p>\n<pre><code>ghci&gt; map (\\(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]  \n[3,8,9,8,7]\n</code></pre>\n<h2 id=\"%E5%85%B3%E9%94%AE%E5%AD%97-fold\" tabindex=\"-1\">关键字 fold</h2>\n<h2 id=\"%E6%9C%89%24%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8\" tabindex=\"-1\">有$的函数调用</h2>\n<p>定义：</p>\n<pre><code>($) :: (a -&gt; b) -&gt; a -&gt; b  \nf $ x = f x\n</code></pre>\n<p><code>sum $ filter (&gt; 10) $ map (*2) [2..10]</code>这不就是倒过来的管道吗?</p>\n<p>除了减少括号外，<code>$</code> 还可以将数据作为函数使用。例如映射一个函数调用符到一组函数组成的 List：</p>\n<pre><code>ghci&gt; map ($ 3) [(4+),(10*),(^2),sqrt]  \n[7.0,30.0,9.0,1.7320508075688772]\n</code></pre>\n<h2 id=\"%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88\" tabindex=\"-1\">函数组合</h2>\n"}